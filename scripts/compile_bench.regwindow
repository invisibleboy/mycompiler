#!/bin/sh
###############################################################################
##
##		      Illinois Open Source License
##                     University of Illinois/NCSA
##                         Open Source License
##
## Copyright (c) 2004, The University of Illinois at Urbana-Champaign.
## All rights reserved.
##
## Developed by:             
##
##		IMPACT Research Group
##
##		University of Illinois at Urbana-Champaign
##
##              http://www.crhc.uiuc.edu/IMPACT
##              http://www.gelato.org
##
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal with the Software without
## restriction, including without limitation the rights to use, copy,
## modify, merge, publish, distribute, sublicense, and/or sell copies
## of the Software, and to permit persons to whom the Software is
## furnished to do so, subject to the following conditions:
##
## Redistributions of source code must retain the above copyright
## notice, this list of conditions and the following disclaimers.
##
## Redistributions in binary form must reproduce the above copyright
## notice, this list of conditions and the following disclaimers in
## the documentation and/or other materials provided with the
## distribution.
##
## Neither the names of the IMPACT Research Group, the University of
## Illinois, nor the names of its contributors may be used to endorse
## or promote products derived from this Software without specific
## prior written permission.  THE SOFTWARE IS PROVIDED "AS IS",
## WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
## LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
## PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
## CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
## OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
## OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
## OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.
##
###############################################################################
#
#	This script compiles a benchmark using IMPACT public release
#       2.10 functionality.  
#
#       Run this script with no arguments for usage information.
#
#       Script created by John C. Gyllenhaal, Wen-mei Hwu 4/29/98
#       Updated for IMPACT release versions 1.01-2.10 by John C. Gyllenhaal
#

##############
# Portability features

LS="/bin/ls"
RM="/bin/rm -f"

##############
# JWS 19991130 Modularity!

Announce() {
   echo " ";
   echo "> ----------------------------------------------------------------------";
   echo "> "$1;
   echo "> `date`";
   echo "> ----------------------------------------------------------------------";
   echo " ";
}

Check() {
   if [ "$1" != "0" ]; then echo "Exiting: non-zero exit code"; exit 1; fi
}

# Check to see if tgz or previous stage will provide starting materials
CB_check_prev() {
   PREV_STAGE=$1
   PREV_EXT=$2
   PREV_STAGE_NAME=$3

   if [ ${PREV_STAGE} -eq 0 ]; then
      if [ ! -f ${BASENAME}.${PREV_EXT}.tgz ]; then
        echo "> Error: Expect ${BASENAME}.${PREV_EXT}.tgz in '.' "
        echo "> or -${PREV_STAGE_NAME} option!";
        VALID_ENV=0;
      fi
   fi
}

CB_tar_up() {
   for TAR_EXT in "$@"; do
      gen_tar ${BASENAME} ${TAR_EXT}
      Check "$?"
   done
}

# Restore files of ext $1 unless any of the following have been performed
CB_restore_unless() {
   UNTAR_EXT=$1
   shift;
   NEED_UNTAR=1
   for arg in "$@"; do
      if [ $arg -eq 1 ]; then
         NEED_UNTAR=0
      fi
   done
   if [ $NEED_UNTAR -eq 1 ]; then
      ${RM} *.${UNTAR_EXT};
      gen_untar ${BASENAME} ${UNTAR_EXT};
      Check "$?"
      echo " ";
   fi
}

# Remove files of ext $1 unless any of the following parameters are set
CB_remove_unless() {
   UNTAR_EXT=$1
   shift;
   NEED_FILES=0
   for arg in "$@"; do
      if [ $arg -eq 1 ]; then
         NEED_FILES=1
      fi
   done
   if [ $NEED_FILES -eq 0 ]; then
      echo " "
      echo "> Removing untarred .${UNTAR_EXT} files"
      ${RM} *.${UNTAR_EXT};
   fi
}

# Assume the IMPACT environment has been properly set up
VALID_ENV=1;

# Determine if IMPACT_REL_PATH environment variable has been defined
release="${IMPACT_REL_PATH}"
if [ "$release" = "" ] ; then
    echo "The environment variable IMPACT_REL_PATH is not defined!!";
    echo "IMPACT's README.install describes how to set up your environment.";
    echo "";
    VALID_ENV=0;

# Determine if the directory IMPACT_REL_PATH exists
elif [ ! -d ${IMPACT_REL_PATH} ]; then
    echo "The directory IMPACT_REL_PATH = ${IMPACT_REL_PATH} is invalid!";
    echo "";
    VALID_ENV=0;
fi;

# Determine if IMPACT_ROOT environment variable has been defined
root="${IMPACT_ROOT}"
if [ "$root" = "" ] ; then
    echo "The environment variable IMPACT_ROOT is not defined!!";
    echo "IMPACT's README.install describes how to set up your environment.";
    echo "";
    VALID_ENV=0;

# Determine if the directory IMPACT_ROOT exists
elif [ ! -d ${IMPACT_ROOT} ]; then
    echo "The directory IMPACT_ROOT = ${IMPACT_ROOT} is invalid!";
    echo "";
    VALID_ENV=0;
fi;

# Set up environment with default values
BASELINE_PARMS_FILE=${STD_PARMS_FILE}
# "${IMPACT_ROOT}/parms/STD_PARMS.compile_bench";
READ_PATHS="";
BEGIN_SETX="";
END_SETX="";
NOCLEAN=0;
FIND_BENCH_DIR=1;
PROJECT_NAME="$DEFAULT_PROJECT"; # Default project unless -project used
LOCAL_SRC=0;

# Parameter overrides for specific modules

OVR_PINLINE="";
OVR_PTOL="";
OVR_LOPTI="";
OVR_LBLOCK="";
OVR_LSUPER="";
OVR_LIMPACT="";
OVR_LHPL_PD="";

DO_SEGMENTS_SPECIFIED=0;
DO_fe_1=0;
DO_fe_2=0;
DO_fe_3=0;
DO_fe_4=0;
DO_fe_5=0;

DO_c2lc=0;
DO_pc2lc=0;
DO_lc2O=0;

DO_O2O_p=0;
DO_O2O_im_p=0;

DO_O_p2S=0;
DO_S2S_im_p=0;    

DO_O_p2H=0;
DO_H2HS=0;
DO_HS2HS_im_p=0;  
DO_HS2HSP=0;
DO_O2O_tr=0;
DO_S2S_tr=0;
DO_HS2HS_tr=0;
DO_O_im_p2O_im_p_sim=0; 
DO_S_im_p2S_im_p_sim=0;
DO_HS_im_p2HS_im_p_sim=0;
DO_LPO=0;
DO_HS_im_p2HS_im_p_ss=0;
DO_O_im_p2O_im_p_ss=0;

OPT_DO_CPP=0;
OPT_KRC_MODE=0;            # K&R (pre-ANSI) C Mode
OPT_INLINE=1;              # Perform inlining
OPT_IPA=1;                 # Interprocedrual Pointer Analysis
OPT_CTL_SPEC=1;            # Control speculative PEIs
OPT_PRED_PROM=1;           # Predicate promotion
OPT_IND_ANAL=0;            # Inductor analysis (Linduct)
OPT_SW_PIPE=0;             # Software pipelining
OPT_RECOVERY_CODE=0;       # Recovery code
OPT_PRE=0;                 # Do PRE in Lopti
OPT_PDE=0;                 # Do PDE in Lopti
OPT_FRP=0;                 # FRP Hyperblock Formation
OPT_DO_SSA=0;
OPT_DO_PCE=0;
OPT_DO_OMEGA=0;


OPT_SPECTR=0;
DISABLE_SYNCARCS=0;
COPY_INTRINSIC_SRC=0;
PREPROCESSOR_OPTIONS="";
PROFILE_OPTIONS="";
PROBE_OPTIONS="";
SIM_OPTIONS="";
LMDES2_SPECIFIED=0;
LMDES2="";
USE_LHPL_PD=0;
TIME="";  # Set by -times option
TRAIN_OPTION="";
TRAIN_LIST="";
TRAIN_PREFIX="";
EVAL_OPTION="";
EVAL_LIST="";
EVAL_PREFIX="";
SIM_PARMS_SETTING="";
S_MAX_SPECID="";

# In order to get -setup, etc. to work properly, I need to break up
# the '-setup' and the "text", so that the "text" can be presented
# as one argument to gen_profiled_pcode and gen_profiled_lcode.
SETUP_CMD="";
SETUP_TEXT="";
CPREFIX_CMD="";
CPREFIX_TEXT="";
ARGS_CMD="";
ARGS_TEXT="";
CHECK_CMD="";
CHECK_TEXT="";
CLEANUP_CMD="";
CLEANUP_TEXT="";
PPROF_INPUT_CMD="";
LPROF_INPUT_CMD="";
SIM_INPUT_CMD="";

# Assume arguments valid
VALID_ARGS=1;

############################
# FIXED ARGUMENTS
#

if [ $# -ge 1 ]; then
   BENCHMARK="$1";
   BASENAME="$1";

   COMPILE_BENCH_ARGS="$*";
   TIME_STAMP=`date`;
   START_DATE=`date +"%T %D"`;
   echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%";
   echo "> Begin 'compile_bench ${COMPILE_BENCH_ARGS}'";
   echo "> Started on $TIME_STAMP"
   echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%";
   echo " "
   
   # skip the 1 set argument
   shift 1;
else
   VALID_ARGS=0;
fi

############################
# VARIABLE ARGUMENTS
#

while [ $# -gt 0 -a $VALID_ARGS -eq 1 ]
do

  # get the next option specified

  OPTION="$1"
  shift

  # compatability conversions

  case $OPTION in
    -*_im)
      echo "> Interpreting '$OPTION' as '${OPTION}_p', for backward compatibility"
      OPTION="${OPTION}_p";;

    -path)
      echo "> Interpreting '$OPTION' as '-bench_dir', for backward compatibility"
      OPTION="-bench_dir";;

    -noinline|-no_inline)
      echo "> Interpreting '$OPTION' as '-no_inlining'"
      OPTION="-no_inlining";;

    -noPIP|-no_PIP|-nopip|-no_pip|-nopointer|-no_pointer|-no_sync)
      echo "> Interpreting '$OPTION' as '-nosync'"
      OPTION="-nosync";;

    -no_intrinsic|-nointrinsics|-no_intrinsics)
      echo "> Interpreting '$OPTION' as '-nointrinsic'"
      OPTION="-nointrinsic";;

    -no_intrinsic2|-nointrinsics2|-no_intrinsics2)
      echo "> Interpreting '$OPTION' as '-nointrinsic2'"
      OPTION="-nointrinsic2";;

    -remainder)
      echo "> Interpreting '$OPTION' as '-remain'"
      OPTION="-remain";;

    -softpipe)
      echo "> Interpreting '$OPTION' as '-pipe'"
      OPTION="-pipe";;
  esac

  case $OPTION in
    # Allow compilation segments to be specified individually, the related 
    # messages will be printed out below.  Allow all caps for ease of use.
    # May specify any combination of individual segments and segment combos.

    -fe1)
      DO_fe_1=1;
      DO_SEGMENTS_SPECIFIED=1;;
    -fe2)
      DO_fe_2=1;
      DO_SEGMENTS_SPECIFIED=1;;
    -fe3)
      DO_fe_3=1;
      DO_SEGMENTS_SPECIFIED=1;;
    -fe4)
      DO_fe_4=1;
      DO_SEGMENTS_SPECIFIED=1;;
    -fe5)
      DO_fe_5=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2p)
      DO_fe_1=1;
      DO_fe_2=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -pprof)
      DO_fe_3=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -p2lc)
      DO_fe_4=1;
      DO_fe_5=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2lc)
      DO_c2lc=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2O_p)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2O)
      DO_lc2O=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2S)
      DO_O_p2S=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2H)
      DO_O_p2H=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2HS)
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -H2HS)
      DO_H2HS=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O2O_p)
      DO_O2O_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O2O_im_p)
      DO_O2O_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -S2S_im_p)
      DO_S2S_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -HS2HS_im_p)
      DO_HS2HS_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O2O_tr)
      DO_O2O_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -S2S_tr)
      DO_S2S_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -HS2HS_tr)
      DO_HS2HS_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_im_p2O_im_p.sim)
      DO_O_im_p2O_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_im_p2O_im_p_ss)
      DO_O_im_p2O_im_p_ss=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -S_im_p2S_im_p.sim)
      DO_S_im_p2S_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -HS_im_p2HS_im_p.sim)
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -HS_im_p2HS_im_p_ss)
      DO_HS_im_p2HS_im_p_ss=1;
      DO_SEGMENTS_SPECIFIED=1;;

    # Segment combos (of the above). 
    -c2O)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2S)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2HS)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2O_im_p)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2S_im_p)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2HS_im_p)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2O_im_p.sim)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_im_p=1;
      DO_O_im_p2O_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2S_im_p.sim)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2HS_im_p.sim)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2O_im_p)
      DO_lc2O=1;
      DO_O2O_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2S_im_p)
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2HS_im_p)
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2O_im_p.sim)
      DO_lc2O=1;
      DO_O2O_im_p=1;
      DO_O_im_p2O_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2S_im_p.sim)
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2HS_im_p.sim)
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2S_im_p)
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2HS_im_p)
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O2O_im_p.sim)
      DO_O2O_im_p=1;
      DO_O_im_p2O_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2S_im_p.sim)
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2HS_im_p.sim)
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -S2S_im_p.sim)
      DO_S2S_im_p=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -HS2HS_im_p.sim)
      DO_HS2HS_im_p=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -HS2HSP)
      DO_HS2HSP=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2O_tr)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O2O_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2S_tr)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_S2S_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2HS_tr)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2O_tr)
      DO_lc2O=1;
      DO_O2O_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2S_tr)
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_S2S_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2HS_tr)
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2S_tr)
      DO_O_p2S=1;
      DO_S2S_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O_p2HS_tr)
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2X_im_p)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_im_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2X_im_p.sim)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_im_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_O_im_p2O_im_p_sim=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2X_im_p)
      DO_lc2O=1;
      DO_O2O_p=1;
      DO_O2O_im_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2X_im_p.sim)
      DO_lc2O=1;
      DO_O2O_im_p=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_O_im_p2O_im_p_sim=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O2X_im_p)
      DO_O2O_im_p=1;
      DO_O2O_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O2X_im_p.sim)
      DO_O2O_im_p=1;
      DO_O_p2S=1;
      DO_S2S_im_p=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_im_p=1;
      DO_O_im_p2O_im_p_sim=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -X2X_im_p)
      DO_O2O_im_p=1;
      DO_S2S_im_p=1;
      DO_HS2HS_im_p=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -X2X_im_p.sim)
      DO_O2O_im_p=1;
      DO_S2S_im_p=1;
      DO_HS2HS_im_p=1;
      DO_O_im_p2O_im_p_sim=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -X_im_p2X_im_p.sim)
      DO_O_im_p2O_im_p_sim=1;
      DO_S_im_p2S_im_p_sim=1;
      DO_HS_im_p2HS_im_p_sim=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -c2X_tr)
      DO_c2lc=1;
      DO_lc2O=1;
      DO_O2O_tr=1;
      DO_O_p2S=1;
      DO_S2S_tr=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -lc2X_tr)
      DO_lc2O=1;
      DO_O2O_tr=1;
      DO_O_p2S=1;
      DO_S2S_tr=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -O2X_tr)
      DO_O2O_tr=1;
      DO_O_p2S=1;
      DO_S2S_tr=1;
      DO_O_p2H=1;
      DO_H2HS=1;
      DO_HS2HS_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -X2X_tr)
      DO_O2O_tr=1;
      DO_S2S_tr=1;
      DO_HS2HS_tr=1;
      DO_SEGMENTS_SPECIFIED=1;;

    -omega)
      OVR_PTOL="${OVR_PTOL} -Fannotate_omega=yes -Fdd_debug_omega=0";;

    -test_omega)
      OPT_DO_OMEGA=1;;

    # Allow pointer analysis to be turned off
    -nosync)
      echo "> Will not invoke sync arc generation (pointer analysis)"
      # Do not allow PtoL to add sync arcs for variables it creates.
      OVR_PTOL="${OVR_PTOL} -Fgenerate_sync_arcs=no"
      OPT_IPA=0;;
    
    # Allow intrinsic support to be turned off
    -nointrinsic)
      echo "> Will not use intrinsic operations (will leave as function calls)"
      OVR_PTOL="$OVR_PTOL -Finsert_intrinsics=no";;

    # Turn off intrinsic support and 
    # flags that intrinsic library source should be copied in with bench source
    -nointrinsic2)
      echo "> Will not use intrinsic operations (will leave as function calls) and "
      OVR_PTOL="$OVR_PTOL -Finsert_intrinsics=no";
      echo "> will copy impact/intrinsic.lib/*.[ch] in addition to bench src"
      COPY_INTRINSIC_SRC=1;;

    -unrestrict)
      echo "> Allowing unrestricted casting (pointer analysis)"
      OVR_PTOL="${OVR_PTOL} -Fallow_unrestricted_casting=yes";;
    
    # Allow remainder loop opti to be turned on
    -remain)
      echo "> Will turn on remainder loop optimization";
      OVR_LSUPER="$OVR_LSUPER -Funroll_with_remainder_loop=yes -Funroll_pipelined_loops=yes";;

    -nosb)
      echo "> Preventing superblock formation"
      OVR_LSUPER="$OVR_LSUPER -Fdo_sb_formation=no";;

    -nobtx)
      echo "> Preventing branch target expansion"
      OVR_LSUPER="$OVR_LSUPER -Fdo_super_branch_target_exp=no";;

    # Allow software pipeliner to be turned on
    # Turn off multiway branch opti also.
    -pipe)    
      OPT_SW_PIPE=1;;

    -nocspec)
      OPT_CTL_SPEC=0;;

    -induct)    
      OPT_IND_ANAL=1;;

    -pre)
      OPT_PRE=1;;

    -pde)
      OPT_PDE=1;;

    -frp)
      OPT_FRP=1;;

    -noprom)
      OPT_PRED_PROM=0;;

    -ssa)
      OPT_DO_SSA=1;;

    -pce)
      OPT_DO_PCE=1;;

    -c++)
      OPT_DO_CPP=1;;

    # Allow different projects to be used
    -project)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects a name after -project"
        exit 1;
      fi
      PROJECT_NAME="$1";
      READ_PATHS="$READ_PATHS -project $PROJECT_NAME";
      shift;;

    # Allow an benchmark dir be specified
    -bench_dir)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects a name after -bench_dir"
        exit 1;
      fi
      BENCH_DIR="$1";
      # Make sure specified path exists
      if [ ! -d $BENCH_DIR ]; then
        echo "Error: Invalid directory specified with -bench_dir option:"
        echo "       '${BENCH_DIR}'"
        exit 1;
      fi
      READ_PATHS="-bench_dir $BENCH_DIR $READ_PATHS";
      FIND_BENCH_DIR=0;
      shift;;
    
    -setx)
      echo '> Will show key commands exactly via "set -x"';
      BEGIN_SETX="set -x";
      END_SETX="set +x";;

    -copy_src)
      echo '> Will compile source fetched via copy_bench_src script (now default)';
      LOCAL_SRC=0;;

    -local_src)
      echo '> Will use the source in "." (instead of using copy_bench_src)';
      LOCAL_SRC=1;;

    -krc)
      echo "> Source is K&R C";
      OPT_KRC_MODE=1;;

    -p)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      NEW_PARMS="$1";
      shift;

      # Make sure parameter file valid in current directory
      if [ ! -f ${NEW_PARMS} ]; then
        echo "Error: Parameter file specified with '-p' not found:";
        echo "       '${NEW_PARMS}'"
        exit 1;
      fi

      # Make absolute path, if not already
      case $NEW_PARMS in
          # If start with ~ or /, path already absolute
          ~*|/*)
            FIXED_PATH=0;;

          # Otherwise, prepend current directory to make absolute path
          *)
             CUR_DIR=`pwd | sed s/.tmp_mnt//`;
             if test "$?" != 0; then
                echo "Error: Non-zero exit code returned by pwd while"
               echo "       patching up '-p $NEW_PARMS' option";
                exit 1;
             fi
             OLD_PARMS="${NEW_PARMS}";
             NEW_PARMS="${CUR_DIR}/${NEW_PARMS}";

             # Make sure new fixed up path valid
             if [ ! -f ${NEW_PARMS} ]; then
                echo "Unexpected error while converting specified parameter file (via -p):";
                echo "    '$OLD_PARMS'";
                echo "into absolute path to parameter file:";
                echo "    '$NEW_PARMS'";
                echo "The fixup up path is not valid!";
                echo "Fix this script or use an absolute path!";
                exit 1;
             fi
             echo "> Interpreting '-p $OLD_PARMS' as:";
             echo ">   '-p $NEW_PARMS'";
             FIXED_PATH=1;;
      esac
      echo "> Will use as the baseline parms for everything (except profiling):";
      echo ">  '${NEW_PARMS}'"
      SIM_PARMS_SETTING="-p ${NEW_PARMS}";
      BASELINE_PARMS_FILE="${NEW_PARMS}";;

    -noclean|-no_clean)
      echo "> Will save ALL the intermediate files using gen_tar";
      NOCLEAN=1;;

    -times)
      echo "> Will perform time measurements on intermediate steps";
      TIME="time";;

    -max_unroll)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      MAX_UNROLL="$1";
      shift;
      # Make sure MAX_UNROLL starts with a number or a +
      case ${MAX_UNROLL} in
        [0-9+]*)
  	  echo "> Will unroll loops a maximum of ${MAX_UNROLL} times.";;
        *)
	  echo "> Error: integer expected after -max_unroll, not '${MAX_UNROLL}'";
        VALID_ARGS=0;;

      esac;;

    -no_inlining|-noinlining)
      echo "> Preventing function inlining (significantly reduces performance)";
      OPT_INLINE=0;
      OVR_PINLINE="$OVR_PINLINE -Fregroup_only=yes";;

    -inlrat)
      if [ $# -eq 0 ]; then
        echo "Error: ia64_compile_bench expects an argument after $OPTION"
        exit 1;
      fi
     INLRAT=$1;
     shift;
     echo "> Inlining ratio ${INLRAT}"
     OVR_PINLINE="$OVR_PINLINE -Fmax_expansion_ratio=${INLRAT}";;

    -inlcost)
      if [ $# -eq 0 ]; then
        echo "Error: ia64_compile_bench expects an argument after $OPTION"
        exit 1;
      fi
     INLCST=$1;
     shift;
     echo "> Inlining cost metric ${INLCST}"
     OVR_PINLINE="$OVR_PINLINE -Finline_key_cost=${INLCST}";;

    -inlidrat)
      if [ $# -eq 0 ]; then
        echo "Error: ia64_compile_bench expects an argument after $OPTION"
        exit 1;
      fi
     INLIDRAT=$1;
     shift;
     echo "> Inlining indir threshold ${INLIDRAT}"
     OVR_PINLINE="$OVR_PINLINE -Findir_thresh=${INLIDRAT}";;

    -inlarat)
      if [ $# -eq 0 ]; then
        echo "Error: ia64_compile_bench expects an argument after $OPTION"
        exit 1;
      fi
     INLARAT=$1;
     shift;
     echo "> Inlining arc ratio ${INLARAT}"
     OVR_PINLINE="$OVR_PINLINE -Fmin_arc_ratio=${INLARAT}";;

    -target)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      LMDES2="$1";
      shift;
      echo "> Using the following machine description for scheduling:"
      echo ">   ${LMDES2}"
      echo " "
      if [ ! -f ${LMDES2} ]; then
        echo "ERROR: ${LMDES2} not found!";
        echo " ";
        VALID_ARGS=0;
      fi
      OVR_LIMPACT="${OVR_LIMPACT} -Flmdes=${LMDES2}";
      OVR_LSUPER="${OVR_LSUPER} -Flmdes=${LMDES2}";
      OVR_LBLOCK="${OVR_LBLOCK} -Flmdes=${LMDES2}";
      LMDES2_SPECIFIED=1;;

    -bench)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      BENCHMARK="$1";
      shift;
      echo "> Using settings for '${BENCHMARK}' instead of for '${BASENAME}";;

    -setup)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      echo " Setup text set to '$1'";
      SETUP_CMD="-setup";
      SETUP_TEXT="$1";
      shift;;

    -cprefix)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      echo " Prefixing '$1' to profile exec command";
      CPREFIX_CMD="-cprefix";
      CPREFIX_TEXT="$1";
      shift;;

    -args)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      echo " Args set to '$1'";
      ARGS_CMD="-args";
      ARGS_TEXT="$1";
      shift;;

    -check)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      echo " Check text set to '$1'";
      CHECK_CMD="-check";
      CHECK_TEXT="$1";
      shift;;

    -cleanup)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      echo " Cleanup text set to '$1'";
      CLEANUP_CMD="-cleanup";
      CLEANUP_TEXT="$1";
      shift;;

    -input)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      if [ "$TRAIN_OPTION" != "" ]; then
        echo "Error: compile_bench does not expect both '$TRAIN_OPTION' and '$OPTION'"
        exit 1;
      fi
      if [ "$EVAL_OPTION" != "" ]; then
        echo "Error: compile_bench does not expect both '$EVAL_OPTION' and '$OPTION'"
        exit 1;
      fi
      TRAIN_OPTION="$OPTION";
      TRAIN_LIST="$1";
      EVAL_OPTION="$OPTION";
      EVAL_LIST="$1";
      shift;;

    -prefix)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      if [ "$TRAIN_OPTION" != "" ]; then
        echo "Error: compile_bench does not expect both '$TRAIN_OPTION' and '$OPTION'"
        exit 1;
      fi
      if [ "$EVAL_OPTION" != "" ]; then
        echo "Error: compile_bench does not expect both '$EVAL_OPTION' and '$OPTION'"
        exit 1;
      fi
      TRAIN_OPTION="$OPTION";
      TRAIN_PREFIX="$1";
      EVAL_OPTION="$OPTION";
      EVAL_PREFIX="$1";
      shift;;

    -train_input)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      if [ "$TRAIN_OPTION" != "" ]; then
        echo "Error: compile_bench does not expect both '$TRAIN_OPTION' and '$OPTION'"
        exit 1;
      fi
      TRAIN_OPTION="$OPTION";
      TRAIN_LIST="$1";
      shift;;

    -train_prefix)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      if [ "$TRAIN_OPTION" != "" ]; then
        echo "Error: compile_bench does not expect both '$TRAIN_OPTION' and '$OPTION'"
        exit 1;
      fi
      TRAIN_OPTION="$OPTION";
      TRAIN_PREFIX="$1";
      shift;;

    -eval_input)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      if [ "$EVAL_OPTION" != "" ]; then
        echo "Error: compile_bench does not expect both '$EVAL_OPTION' and '$OPTION'"
        exit 1;
      fi
      EVAL_OPTION="$OPTION";
      EVAL_LIST="$1";
      shift;;

    -eval_prefix)
      if [ $# -eq 0 ]; then
        echo "Error: compile_bench expects an argument after $OPTION"
        exit 1;
      fi
      if [ "$EVAL_OPTION" != "" ]; then
        echo "Error: compile_bench does not expect both '$EVAL_OPTION' and '$OPTION'"
        exit 1;
      fi
      EVAL_OPTION="$OPTION";
      EVAL_PREFIX="$1";
      shift;;

# JWS Experimental options

    -LB_no_peel)
      OVR_LBLOCK="${OVR_LBLOCK} -Fpeel_enable=no";;
      
    -LB_issue_width)
      if [ $# -eq 0 ]; then echo "Error: $OPTION requires arg."; exit 1; fi;
      VAL=$1;
      OVR_LBLOCK="${OVR_LBLOCK} -Fissue_width=${VAL}";
      shift;;
     
    -LB_path_max_op_growth)
      if [ $# -eq 0 ]; then echo "Error: $OPTION requires arg."; exit 1; fi;
      VAL=$1;
      OVR_LBLOCK="${OVR_LBLOCK} -Fpath_max_op_growth=${VAL}";
      shift;;

    -LB_path_max_dep_growth)
      if [ $# -eq 0 ]; then echo "Error: $OPTION requires arg."; exit 1; fi;
      VAL=$1;
      OVR_LBLOCK="${OVR_LBLOCK} -Fpath_max_dep_growth=${VAL}";
      shift;;

# JWS END
    -L*|-l*)
      echo "> Will add '${OPTION}' to the link command";
      if [ "$PROFILE_OPTIONS" != "" ]; then
         PROFILE_OPTIONS="${PROFILE_OPTIONS} ${OPTION}";
      else
         PROFILE_OPTIONS="${OPTION}";
      fi
      if [ "$PROBE_OPTIONS" != "" ]; then
         PROBE_OPTIONS="${PROBE_OPTIONS} ${OPTION}";
      else
         PROBE_OPTIONS="${OPTION}";
      fi;;

    -l*)
      echo "> Will add '${OPTION}' to the link command";
      if [ "$PROFILE_OPTIONS" != "" ]; then
         PROFILE_OPTIONS="${PROFILE_OPTIONS} ${OPTION}";
      else
         PROFILE_OPTIONS="${OPTION}";
      fi
      if [ "$PROBE_OPTIONS" != "" ]; then
         PROBE_OPTIONS="${PROBE_OPTIONS} ${OPTION}";
      else
         PROBE_OPTIONS="${OPTION}";
      fi;;

    -I*|-D*)
      echo "> Adding '$OPTION' to the preprocessor command";
      if [ "$PREPROCESSOR_OPTIONS" != "" ]; then
         PREPROCESSOR_OPTIONS="${PREPROCESSOR_OPTIONS} ${OPTION}";
      else
         PREPROCESSOR_OPTIONS="${OPTION}";
      fi;;

    -str)
      echo "> Enabling tracing of load speculation";
      if [ "$OVR_LSUPER" != "" ]; then
         OVR_LSUPER="${OVR_LSUPER} -Fgenerate_spec_checks=yes";
      else
         OVR_LSUPER="-Fgenerate_spec_checks=yes";
      fi;
      if [ "$OVR_LIMPACT" != "" ]; then
         OVR_LIMPACT="${OVR_LIMPACT} -Fgenerate_spec_checks=yes";
      else
         OVR_LIMPACT="-Fgenerate_spec_checks=yes";
      fi;
      if [ "$SIM_OPTIONS" != "" ]; then
         SIM_OPTIONS="${SIM_OPTIONS} -str";
      else
         SIM_OPTIONS="-str";
      fi;
      OPT_SPECTR=1;;
     
    -pred_opti)
     echo "> Performing predicate define network optimization";
     DO_LPO=1;;

    *)
      echo "Error: Unknown option '${OPTION}'"
      VALID_ARGS=0;;
  esac
done

PROFILE_OPTIONS="-bench ${BENCHMARK} ${PROFILE_OPTIONS}";
PREPROCESSOR_OPTIONS="-bench ${BENCHMARK} ${PREPROCESSOR_OPTIONS}";
if [ "$BASENAME" != "$BENCHMARK" ]; then
   PROBE_OPTIONS="-bench $BENCHMARK $PROBE_OPTIONS";
   SIM_OPTIONS="-bench $BENCHMARK $SIM_OPTIONS";
fi

if [ $OPT_DO_CPP -eq 1 ]; then
   PROFILE_OPTIONS="${PROFILE_OPTIONS} -c++"
fi

# Allow software pipelining to be turned on by -pipe
if [ $OPT_SW_PIPE -eq 1 ]; then
   echo "> Will perform software pipelining (disables multiway branch opti)"
   OVR_LIMPACT="${OVR_LIMPACT} -Fdo_software_pipelining=yes";
   OVR_LSUPER="$OVR_LSUPER -Fmark_softpipe_loops=yes -Fdo_multiway_branch_opti=no";
fi

if [ $OPT_DO_PCE -eq 1 ]; then
   echo "> Performing PCE in Lopti"
   OVR_LOPTI="${OVR_LOPTI} -Fdo_PCE=yes -Fdo_PRE=yes -Fdo_PRE_speculative_code_motion=yes -Fdo_PDE=yes -Fdo_PDE_min_cut=yes";
fi

if [ $OPT_PRE -eq 1 ]; then
   echo "> Performing PRE in Lopti"
   OVR_LOPTI="${OVR_LOPTI} -Fdo_PRE=yes";
fi

if [ $OPT_PDE -eq 1 ]; then
   echo "> Performing PDE in Lopti"
   OVR_LOPTI="${OVR_LOPTI} -Fdo_PDE=yes";
fi

if [ $OPT_FRP -eq 1 ]; then
   echo "> Performing FRP Hyperblock Formation in Lblock"
   OVR_LBLOCK="${OVR_LBLOCK} -Fpredicate_formation_type=frp";
   OVR_LSUPER="${OVR_LSUPER} -Fpredicate_formation_type=frp";
fi



# Don't do segment messages and checks if already in error state
if [ $VALID_ARGS -eq 1 -a $VALID_ENV -eq 1 ]; then
  # Find the benchmark dir if not user specified
  if [ $FIND_BENCH_DIR -eq 1 ]; then
    BENCH_DIR=`find_bench_dir ${BENCHMARK}`
    if test "$?" != 0; then
      echo " "
      echo "> Exiting: Could not find '${BENCHMARK}' using find_bench_dir!"
      echo "> Error message returned by find_bench_dir:"
      echo "$BENCH_DIR";
      exit 1;
    fi
  fi

  # Make sure project name set!
  if [ "${PROJECT_NAME}" = "" ]; then
     echo " "
     echo "> Exiting: Environment variable 'DEFAULT_PROJECT' must be defined by user!"
     echo ">          See README.install for instructions on setting this variable."
     exit 1;
  fi

  # Get project dir so we can export below
  PROJECT_DIR=`find_project_dir ${PROJECT_NAME}`
  if test "$?" != 0; then
     echo " "
     echo "> Exiting: Could not find '${PROJECT_NAME}' using find_project_dir!"
     echo "> Error message returned by find_project_dir:"
     echo "$PROJECT_DIR";
     exit 1;
  fi
fi

# Don't do segment messages and checks if already in error state
if [ $VALID_ARGS -eq 1 -a $VALID_ENV -eq 1 ]; then

  # If no segment or combo options were specified, default to settings
  # for the -c2X_im_p option
  if [ $DO_SEGMENTS_SPECIFIED -eq 0 ]; then
    DO_c2lc=1;
    DO_lc2O=1;
    DO_O2O_p=1;
    DO_O2O_im_p=1;
    DO_O_p2S=1;
    DO_S2S_im_p=1;
    DO_O_p2H=1;
    DO_H2HS=1;
    DO_HS2HS_im_p=1;
    if [ $DO_LPO -eq 1 ]; then
	DO_HS2HSP=1;
    fi;
  fi

  # Print out message for each segment invoked.   Also make sure each segment 
  # has a producer or the appropriate tgz file exists
   
  if [ $DO_c2lc -eq 1 ]; then
    echo "> Will do c (C source) to lc (unoptimized Lcode) segment"
    DO_fe_1=1;
    DO_fe_2=1;
    DO_fe_3=1;
    DO_fe_4=1;
    DO_fe_5=1;
  fi

  if [ $DO_fe_1 -eq 1 ]; then
    # If there is no /src directory in $BENCH_DIR, default to local src
    if [ $LOCAL_SRC -ne 1 -a ! -d ${BENCH_DIR}/src ]; then
      C_FILE_LIST="`${LS} *.c 2>/dev/null`"
      if [ "$C_FILE_LIST" = "" ]; then
        echo "> Error: There is no source provided for ${BENCHMARK} and"
        echo ">        there are no .c files in '.'!"
        echo " ";
      else
        echo "> Warning: There is no source provided for ${BENCHMARK}"
        echo ">          so the .c files in "." will be used (-local_src)!";
        echo ' '
        LOCAL_SRC=1;
      fi
    fi;

    # If -c2lc and -local_src, make sure have src is valid
    if [ $LOCAL_SRC -eq 1 ]; then
      C_FILE_LIST="`ls *.c 2>/dev/null`"
      if [ "$C_FILE_LIST" = "" ]; then
        echo "> Error: Expect at least one .c file in '.' with -local_src!";
        echo " ";
        VALID_ENV=0;
      fi
    fi
  fi

  if [ $DO_lc2O -eq 1 ]; then
    echo "> Will do lc to O (classical optimization, no ILP) segment"
    CB_check_prev $DO_c2lc lc c2lc
  fi

  if [ $DO_O2O_im_p -eq 1 ]; then
    echo '> Will do O to O_im_p (scheduled/reg_allocated "assembly" + stats) segment';
    CB_check_prev $DO_lc2O O lc2O
  fi

  if [ $DO_O2O_p -eq 1 ]; then
    echo '> Will do O to O_p segment';
    CB_check_prev $DO_lc2O O lc2O
  fi

  if [ $DO_O_im_p2O_im_p_sim -eq 1 ]; then
    echo '> Will do O_im_p to O_im_p.sim (full system simulation) segment';
    CB_check_prev $DO_O2O_im_p O_im_p O2O_im_p
  fi

  if [ $DO_O_p2S -eq 1 ]; then
    echo "> Will do O to S (superblocks + ILP, no predication) segment";
    CB_check_prev $DO_O2O_p O_p O2O_p
  fi

  if [ $DO_S2S_im_p -eq 1 ]; then
    echo '> Will do S to S_im_p (scheduled/reg_allocated "assembly" + stats) segment';
    CB_check_prev $DO_O_p2S S O_p2S
  fi

  if [ $DO_S_im_p2S_im_p_sim -eq 1 ]; then
    echo '> Will do S_im_p to S_im_p.sim (full system simulation) segment';
    CB_check_prev $DO_S2S_im_p S_im_p S2S_im_p
  fi

  if [ $DO_O_p2H -eq 1 ]; then
    echo "> Will do O_p to H (hyperblocks) segment";
    CB_check_prev $DO_O2O_p O_p O2O_p
  fi

  if [ $DO_H2HS -eq 1 ]; then
    echo "> Will do H to HS (ILP, predicated) segment";
    CB_check_prev $DO_O_p2H H O_p2H
  fi

  if [ $DO_HS2HS_im_p -eq 1 ]; then
    echo '> Will do HS to HS_im_p (scheduled/reg_allocated "assembly" + stats) segment'
   if [ $DO_H2HS -eq 0 ]; then
      if [ ! -f ${BASENAME}.HS.tgz ]; then
        echo "> Error: Expect ${BASENAME}.HS.tgz in '.' or -*2HS option!";
        VALID_ENV=0;
      fi
   fi
  fi

  if [ $DO_HS_im_p2HS_im_p_sim -eq 1 ]; then
    echo '> Will do HS_im_p to HS_im_p.sim (full system simulation) segment';
    CB_check_prev $DO_HS2HS_im_p HS_im_p HS2HS_im_p
  fi

  if [ $DO_O2O_tr -eq 1 ]; then
    echo "> Will do O to O_tr (Trimaran bridge code) segment";
    CB_check_prev $DO_lc2O O lc2O
  fi

  if [ $DO_S2S_tr -eq 1 ]; then
    echo "> Will do S to S_tr (Trimaran bridge code) segment";
    CB_check_prev $DO_O_p2S S O_p2S
  fi

  if [ $DO_HS2HS_tr -eq 1 ]; then
    echo "> Will do HS to HS_tr (Trimaran bridge code) segment";
    CB_check_prev $DO_H2HS HS H2HS
  fi
fi

# Make sure benchmark can be found by the bench_info scripts 
# Assume benchmark info present
VALID_BENCHMARK=1;

# Don't bother with more tests if already in an error state
if [ $VALID_ENV -eq 1 -a $VALID_ARGS -eq 1 ]; then

  echo " ";
  echo "> Will use the compilation and execution info for ${BENCHMARK} in:"
  echo ">   $BENCH_DIR"

  # Get and verify benchmark train inputs
  TRAIN_ERROR_CODE=0;

  # Handle -train_prefix and train portion of -prefix
  if [ "$TRAIN_OPTION" = "-train_prefix" -o \
       "$TRAIN_OPTION" = "-prefix" ]; then
    echo "> Using train prefix '$TRAIN_PREFIX' to find inputs for Pcode profiling"
    TRAIN_LIST="`(find_bench_inputs ${BENCHMARK} $READ_PATHS -prefix \"$TRAIN_PREFIX\") 2>&1`";
    TRAIN_ERROR_CODE="$?";
  
  # Handle -train_input and train portion of -input
  elif [ "$TRAIN_OPTION" = "-train_input" -o \
         "$TRAIN_OPTION" = "-input" ]; then
    echo "> Verifying specified train input list for Pcode profiling"
    TRAIN_LIST="`(find_bench_inputs ${BENCHMARK} $READ_PATHS -input \"$TRAIN_LIST\") 2>&1`";
    TRAIN_ERROR_CODE="$?";

  elif [ "$TRAIN_OPTION" = "-train_eval" ]; then
    echo "> UNSPEAKABLE EVIL! USING EVAL INPUTS FOR TRAINING!"
    TRAIN_LIST="`(find_bench_inputs ${BENCHMARK} $READ_PATHS -eval_inputs) 2>&1`";
    TRAIN_ERROR_CODE="$?";

  # Handle default cause, using train_inputs
  elif [ "$TRAIN_OPTION" = "" ]; then
    TRAIN_LIST="`(find_bench_inputs ${BENCHMARK} $READ_PATHS -train_inputs) 2>&1`";
    TRAIN_ERROR_CODE="$?";
  fi

  if test "$TRAIN_ERROR_CODE" != 0; then
    echo " "
    echo "> Exiting compile_bench, find_bench_inputs returned this error message:"
    echo "$TRAIN_LIST";
    exit 1;
  fi

  # Suppress train input info if not doing c2lc segment
  if [ $DO_c2lc -eq 1 -o $DO_pc2lc -eq 1 ]; then
     echo " "
     echo "> The following input(s) will be used for Pcode profiling/training:"
     echo ">   $TRAIN_LIST"
  fi
  # Cause TRAIN_LIST to be used (instead of ignored by gen_profiled_pcode)
  PPROF_INPUT_CMD="-input";
 
  # Get and verify benchmark eval inputs
  EVAL_ERROR_CODE=0;

  # Handle -eval_prefix and eval portion of -prefix
  if [ "$EVAL_OPTION" = "-eval_prefix" -o \
       "$EVAL_OPTION" = "-prefix" ]; then
    echo "> Using eval prefix '$EVAL_PREFIX' to find inputs for .X_im_p file prof/eval"
    EVAL_LIST="`(find_bench_inputs ${BENCHMARK} $READ_PATHS -prefix \"$EVAL_PREFIX\") 2>&1`";
    EVAL_ERROR_CODE="$?";
   
  # Handle -eval_input and eval portion of -input
  elif [ "$EVAL_OPTION" = "-eval_input" -o \
         "$EVAL_OPTION" = "-input" ]; then
    echo "> Verifying specified eval input list for .X_im_p file profiling/evaluation"
    EVAL_LIST="`(find_bench_inputs ${BENCHMARK} $READ_PATHS -input \"$EVAL_LIST\") 2>&1`";
    EVAL_ERROR_CODE="$?";

  # Handle default cause, using eval_inputs
  elif [ "$EVAL_OPTION" = "" ]; then
    EVAL_LIST="`(find_bench_inputs ${BENCHMARK} $READ_PATHS -eval_inputs) 2>&1`";
    EVAL_ERROR_CODE="$?";
  fi

  if test "$EVAL_ERROR_CODE" != 0; then
    echo " "
    echo "> Exiting compile_bench, find_bench_inputs returned this error message:"
    echo "$EVAL_LIST";
    exit 1;
  fi
  # Suppress train input info if not doing a X2X_im_p segment
  if [ $DO_O2O_im_p -eq 1 -o $DO_S2S_im_p -eq 1 -o $DO_HS2HS_im_p -eq 1 ]; then
     echo " "
     echo "> The following input(s) will be used to prof/eval the final .X_im files:"
     echo ">   $EVAL_LIST"
  fi
  # Cause EVAL_LIST to be used (instead of ignored by gen_profiled_lcode)
  LPROF_INPUT_CMD="-input";
  # Cause EVAL_LIST to be used (instead of ignored by sim_bench)
  SIM_INPUT_CMD="-input";

  # Read project_info to determine if override parameters needed to
  # get benchmark to compile properly 
  PROJECT_PARMS_FILE="`read_project_info $BENCHMARK $READ_PATHS -parm_override_file`";
  if test "$?" != 0; then
    echo "> Error: read_project_info ${BENCHMARK} -parm_override_file returned:"
    echo "${PROJECT_PARMS_FILE}"
    echo "> Exiting: unexpected error in compile_bench ";
    exit 1;
  fi    
fi

# If user specified different max unroll (through -max_unroll or -less_ILP,
# override the Lsuperscalar parameter
if [ "${MAX_UNROLL}" != "" ]; then
    OVR_LSUPER="${OVR_LSUPER} \
	-Fmax_unroll_allowed=${MAX_UNROLL}";
fi

if [ "${OPT_CTL_SPEC}" == "0" ]; then
    echo "> Suppressing control speculation"
    OVR_LOPTI="${OVR_LOPTI} -Fnon_excepting_ops=0";
    OVR_LBLOCK="${OVR_LBLOCK} -Fnon_excepting_ops=0";
    OVR_LSUPER="${OVR_LSUPER} -Fnon_excepting_ops=0";
    OVR_LIMPACT="${OVR_LIMPACT} -Fnon_excepting_ops=0";
fi

if [ "${OPT_PRED_PROM}" == "0" ]; then
    echo "> Suppressing predicate promotion"
    OVR_LSUPER="${OVR_LSUPER} -Fpred_promotion_level=0";
    OVR_LIMPACT="${OVR_LIMPACT} -Fpred_promotion_level=0";
fi

# Allow -krc to be specified in presets or on the command line
if [ $OPT_KRC_MODE -eq 1 ]; then
  PROFILE_OPTIONS="${PROFILE_OPTIONS} -krc";
  PROBE_OPTIONS="${PROBE_OPTIONS} -krc";
  PREPROCESSOR_OPTIONS="${PREPROCESSOR_OPTIONS} -krc";
fi

# Make sure parameter file specified exists
if [ $VALID_ARGS -eq 1 -a ! -f ${BASELINE_PARMS_FILE} ]; then
    echo " "
    echo "ERROR: The following baseline parameter file could not be found:"
    echo "  ${BASELINE_PARMS_FILE}"
    echo " "
    echo "  One solution is to the '-p parms_file' option to pick a different file."
    echo " "
    VALID_ENV=0;
fi

if [ $VALID_ARGS -eq 0 -o $VALID_ENV -eq 0 -o $VALID_BENCHMARK -eq 0 ]; then
    echo ' ';
    echo '> Usage: compile_bench benchmark [options]';
    echo '> ';
    echo '> Generates ILP-optimized "assembly" from the benchmark'\''s .c files in the';
    echo '> current directory using the IMPACT compiler (essentially "cc +O4 *.c").'
    echo '> This source is initially profiled to drive inlining and ILP optimization.'
    echo '> The final "assembly" is profiled to verify correctness.  Static performance'
    echo '> estimates are generated based on the final code schedule and the new profile.';
    echo '> Full system simulation of the final code may also be performed, if desired.';
    echo '> ';
    echo '> Compiler configuration determined by the project parameters and (unless'
    echo '> "-p baseline_parms" is specified) impact/parms/STD_PARMS.compile_bench.';
   echo '> ';
    echo '> Zero or more of the following options may be specified.';
    echo '> ';
    echo '> Individual compilation segment options (default combo is -c2X_im_p):';
    echo '>   -c2lc                do c (C source) to lc (unoptimized Lcode) segment';
    echo '>   -lc2O                do lc to O (classical optimizations, no ILP) segment';
    echo '>   -O_p2S                 do O to S (superblocks + ILP, no predication) segment';
    echo '>   -O_p2HS                do O to HS (hyperblocks + ILP, predicated) segment';
    echo '>   -O2O_im_p            do O to O_im_p (sched/reg_alloc "assembly" + stats)';
    echo '>   -S2S_im_p            do S to S_im_p (sched/reg_alloc "assembly" + stats)';
    echo '>   -HS2HS_im_p          do HS to HS_im_p (sched/reg_alloc "assembly" + stats)';
    echo '>   -O_im_p2O_im_p.sim   do O_im_p to O_im_p.sim (full system simulation)';
    echo '>   -S_im_p2S_im_p.sim   do S_im_p to S_im_p.sim (full system simulation)';
    echo '>   -HS_im_p2HS_im_p.sim do HS_im_p to HS_im_p.sim (full system simulation)';
    echo '>   -O2O_tr              do O to O_tr (Trimaran bridge code) segment';
    echo '>   -S2S_tr              do S to S_tr (Trimaran bridge code) segment';
    echo '>   -HS2HS_tr            do HS to HS_tr (Trimaran bridge code) segment';
    echo '> ';
    echo '> Combo compilation segment options (combinations of above options):';
    echo '>   -(start)2(end)       turn on segments required to get from (start) to (end)';
    echo '>   -c2X_im_p            same as -c2O_im_p -c2S_im_p -c2HS_im_p (default)';
    echo '>   -c2X_im_p.sim        same as -c2O_im_p.sim -c2S_im_p.sim -c2HS_im_p.sim';
    echo '>   -c2X_tr              same as -c2O_tr -c2S_tr -c2HS_tr';
    echo '>   -X2X_im_p            same as -O2O_im_p -S2S_im_p -HS2HS_im_p';
    echo '>   -X2X_im_p.sim        same as -O2O_im_p.sim -S2S_im_p.sim -HS2HS_im_p.sim';
    echo '>   -X2X_tr              same as -O2O_tr -S2S_tr -HS2HS_tr';
    echo '>   -X_im_p2X_im_p.sim   same as -O_im_p2O_im_p.sim ... -HS_im_p2HS_im_p.sim';
    echo '> ';
    echo '> General options:';
    echo '>   -nosync              do not generate sync arcs (no pointer analysis)';
    echo '>   -nointrinsic         do not generate intrinsic ops (they remain jsrs)';
    echo '>   -nointrinsic2        no intrinsics and compile in intrinsic library src'
    echo '>   -remain              perform remainder loops optimization';
    echo '>   -pipe                perform software pipelining';
    echo '>   -copy_src            use copy_bench_src to get benchmark source (default)';
    echo '>   -local_src           use bench source in "." (default: copy over bench src)';
    echo '>   -noclean             saves ALL the intermediate files using gen_tar';
    echo '>   -times               perform time measurements on the intermediate steps';
    echo '>   -setx                show key commands exactly via "set -x"';
    echo '> ';
    echo "> Options for selecting different bench_info settings:";
    echo '>   -project "project"   project info to use (default: $DEFAULT_PROJECT used)';
    echo '>   -bench_dir "dir"     read info in "dir" (default: find_bench_dir used)';
    echo '>   -bench "name"        uses settings for "name" (default: for "benchmark")';
    echo '> ';
    echo "> Options for overriding the benchmark's bench_info settings:";
    echo '>   -input "name(s)"     train/eval with "name(s)" (default: project inputs)';
    echo '>   -prefix "prefix"     train/eval with "prefix*" (default: project inputs)';
    echo '>   -train_input "ns"    train with "name(s)" (default: project train inputs)';
    echo '>   -train_prefix "p"    train with "p*" (default: project train inputs)';
    echo '>   -eval_input "ns"     eval with "name(s)" (default: project eval inputs)';
    echo '>   -eval_prefix "p"     eval with "p*" (default: project eval inputs)';
    echo '>   -p baseline_parms    use baseline_parms (default: STD_PARMS.compile_bench)'
    echo '>   -target "lmdes2"     schedule using "lmdes2" (default: project lmdes2 file)';
    echo '> ';
    echo "> Options for overriding the benchmark's compile_info portion of bench_info:";
    echo '>   -krc                 source is K&R c (default: Ansi-C)';
    echo '>   -Dname=def           define name to the preprocessor';
    echo '>   -Idir                adds "dir" to include search path';
    echo '>   -Ldir                adds "dir" to library search path';
    echo '>   -llibrary            use the library named "library" when linking';
    echo '>   -max_unroll int      unroll loops a maximum of "int" times';
    echo '>   -no_inlining         prevents function inlining (default: inlining)';

    echo '> ';
    echo "> Options for overriding the benchmark's exec_info portion of bench_info:";
    echo '>   -setup   "text"      runs "text" to setup profile run';
    echo '>   -cprefix "text"      prefixes "text" to profile_exec_command';
    echo '>   -args    "text"      sets profile execution arguments to "text"';
    echo '>   -check   "text"      runs "text" to check output';
    echo '>   -cleanup "text"      runs "text" to cleanup after profile run';
    echo '> '
    echo '>   -str                 enables tracing of load speculation';
    echo '>   -pred_opti           enables predicate define optimization';
    exit 1;
fi;

PLATFORM_DIR_SRC="${IMPACT_REL_PATH}/platform/${IMPACT_HOST_PLATFORM}_${IMPACT_HOST_COMPILER}";
PLATFORM_DIR_BLD="${IMPACT_ROOT}/platform/${IMPACT_HOST_PLATFORM}_${IMPACT_HOST_COMPILER}";

############################################################################
#       Starting compilation
############################################################################

   Announce "Setting up for ${BASENAME}"

############################################################################
#       Copy benchmark source unless -local_src option selected 
#       or not doing frontend
############################################################################

    TARG_DIR=".";

    if [ $LOCAL_SRC -eq 0 -a $DO_fe_1 -eq 1 ]; then
        echo " "
	echo "> Creating 'impactbenchsrc' to hold copy of ${BENCHMARK} source"
	${RM} -r impactbenchsrc
        mkdir impactbenchsrc

	TARG_DIR="impactbenchsrc";

        if [ $COPY_INTRINSIC_SRC -eq 1 ]; then
           echo " ";
           echo "> Copying impact/intrinsic.lib/*.[ch] into impactbenchsrc";
           cp ${IMPACT_REL_PATH}/intrinsic.lib/*.[ch] impactbenchsrc
           if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
        fi

        echo " ";
        copy_bench_src ${BENCHMARK} $READ_PATHS -dest impactbenchsrc
	Check "$?"
   fi

   # If interprocedural analysis is to be performed, copy in Pcode
   # for commonly called system functions.

   if [ $OPT_IPA -eq 1 ]; then
      cp ${PLATFORM_DIR_BLD}/IPA_lib/__impact_lib.pst ${TARG_DIR}/
      cp ${PLATFORM_DIR_BLD}/IPA_lib/__impact_intrinsic.pst ${TARG_DIR}/
      Check "$?"

      if [ $OPT_DO_CPP -eq 1 ]; then
         cp ${PLATFORM_DIR_BLD}/IPA_lib/__impact_lib2.pst ${TARG_DIR}/
         Check "$?"
      fi
   fi


############################################################################
#       Override user's STD_PARMS_FILE setting
############################################################################

    # The bench info infrastructure requires that BASELINE_PARMS_FILE be
    # exported for use by the compile_parms file in each benchmark directory
    # (which in turn is used by the PROJECT_PARMS_FILE).  This is how
    # the user's parameters (if specified with -p), or the default 
    # compile benchmark parameters, are reached.
    echo " ";
    echo "> Exporting BASELINE_PARMS_FILE for use by ${BENCHMARK}/compile_parms:";
    echo ">   $BASELINE_PARMS_FILE";
    $BEGIN_SETX
    export BASELINE_PARMS_FILE;
    $END_SETX

    # The project info infrastructure requires that PROJECT_DIR and BENCH_DIR 
    # be exported for use by the PROJECT_PARMS_FILE.  This allows the
    # project to find and override the compile_parms in each benchmark 
    # directory.  
    echo ">"
    echo "> Exporting BENCH_DIR for use by ${PROJECT_NAME}/project_parms";
    echo ">   $BENCH_DIR";
    echo ">"
    echo "> Exporting PROJECT_DIR for use by ${PROJECT_NAME}/project_parms_${BENCHMARK}:";
    echo ">   $PROJECT_DIR";
    $BEGIN_SETX
    export PROJECT_DIR
    export BENCH_DIR
    $END_SETX


    # All the IMPACT modules will use STD_PARMS_FILE to determine the 
    # parameter file.  Set this to the PROJECT_PARMS_FILE and export.
    echo ">"
    echo "> Exporting STD_PARMS_FILE for use by IMPACT modules:"
    echo ">   $PROJECT_PARMS_FILE";
    $BEGIN_SETX
    STD_PARMS_FILE="$PROJECT_PARMS_FILE";
    export STD_PARMS_FILE;
    $END_SETX

# CWL
# for gdb

#    echo "set environment BASELINE_PARMS_FILE=${BASELINE_PARMS_FILE}" > .gdbinit
#    echo "set environment PROJECT_DIR=${PROJECT_DIR}" >> .gdbinit
#    echo "set environment BENCH_DIR=${BENCH_DIR}" >> .gdbinit
#    echo "set environment STD_PARMS_FILE=${STD_PARMS_FILE}" >> .gdbinit

############################################################################
#    Part 1/6 of the c2lc compilation segment
#    Run the EDG front-end 
############################################################################

if [ -s gmon.out ]; then rm gmon.out; fi;

if [ $DO_fe_1 -eq 1 ]; then
    ${RM} *.pc

    if [ $LOCAL_SRC -eq 0 ]; then
	Announce "c2gp 1/6: EDG frontend on the *.c in impactbenchsrc";
	cd impactbenchsrc
	Check "$?"
    else
	Announce "c2lc 1/6: EDG frontend on the *.c in '.'";
    fi

    if [ "$PREPROCESSOR_OPTIONS" != "" -o "$READ_PATHS" != "" ]; then
       echo " ";
       echo "> The following options will be passed to gen_CtoP:"
       echo ">   $READ_PATHS $PREPROCESSOR_OPTIONS"
    fi

    echo " ";
    SOURCES=`read_compile_info $BENCHMARK $READ_PATHS -sources`;
    Check "$?"

    if [ "$SOURCES" = "" ]; then
      SOURCES="*.c";
    fi;

    $BEGIN_SETX
    gen_CtoP $READ_PATHS $PREPROCESSOR_OPTIONS $SOURCES;
    Check "$?"
    $END_SETX

    # If compiled in impactbenchsrc, move back to original dir
    if [ $LOCAL_SRC -eq 0 ]; then
      mv *.pstl ..
      Check "$?"
      cd ..
    fi    

    if [ $NOCLEAN -eq 1 ]; then
        CB_tar_up pstl
    else
        # If copied and preprocessed source in impactbenchsrc, delete it now 
        # unless -noclean specified
        if [ $LOCAL_SRC -eq 0 ]; then
           echo " ";
           echo "> Removing impactbenchsrc"
	   ${RM} -r impactbenchsrc
        fi
    fi
fi

############################################################################
#    Part 2/6 of the c2lc compilation segment
#    Perform Pcode flattening
############################################################################

if [ $DO_fe_2 -eq 1 ]; then

    Announce "c2lc 2/6: Performing Pcode flattening";

    ${RM} *.pcf

   Pflatten -i a.out.pstl -o pcf
   Check "$?"

   if [ $NOCLEAN -eq 1 ]; then
      CB_tar_up pcf
   fi

   ${RM} *.pstl;
fi

############################################################################
#    Part 3/6 of the c2lc compilation segment
#    Perform Pcode profiling
############################################################################

if [ $DO_fe_3 -eq 1 ]; then

    Announce "c2lc 3/6: Pcode profiling using settings for ${BENCHMARK}";

    ${RM} *.pcf_p

    $BEGIN_SETX
    ${TIME} gen_profiled_pcode . -ext pcf -noflatten \
        $READ_PATHS $PROFILE_OPTIONS \
        $PPROF_INPUT_CMD "$TRAIN_LIST" \
        $SETUP_CMD "$SETUP_TEXT" $CPREFIX_CMD "$CPREFIX_TEXT" \
        $ARGS_CMD "$ARGS_TEXT" $CHECK_CMD "$CHECK_TEXT" \
        $CLEANUP_CMD "$CLEANUP_TEXT";
    Check "$?"
    $END_SETX

    if [ $NOCLEAN -eq 1 ]; then
       CB_tar_up pcf_p
    fi

    ${RM} *.pcf;
fi

############################################################################
#    Part 4/6 of the c2lc compilation segment
#    Perform inlining on Pcode files
############################################################################

if [ $DO_fe_4 -eq 1 ]; then

    if [ $OPT_INLINE -eq 1 ]; then
        Announce "> c2gp 5/6: Performing Pcode inlining";
    else
        Announce "> c2gp 5/6: Skipping Pcode inlining";
    fi

    ${RM} *.pci

    Pinline -i a.out.pcf_p -o pci ${OVR_PINLINE};

    if [ $NOCLEAN -eq 1 ]; then
	CB_tar_up pci
    fi

    ${RM} *.pcf_p;
fi

############################################################################
#    Part 5/5 of the c2lc compilation segment
#    Convert Pcode files to Lcode (plus pointer analysis)
############################################################################

if [ $DO_fe_5 -eq 1 ]; then

    # Get benchmarks' default for disabling sync arcs for module's use
    DISABLE_SYNCARCS=`read_compile_info ${BENCHMARK} $READ_PATHS -disable_syncarcs`;
    if test "$?" != 0; then
       echo " "
       echo "> Exiting: Could not read default disable_syncarcs using read_compile_info!"
       echo "> Error message returned by read_compile_info:"
       echo "$DISABLE_SYNCARCS";
       exit 1;
    fi
    if [ $DISABLE_SYNCARCS -eq 1 ]; then
      echo "> c2lc segment 6/6:  Disabling sync arc generation from benchmark compile_info"
      if [ $OPT_IPA -eq 1 ]; then
         # Do not allow HtoL to add sync arcs for variables it creates.
         OVR_PTOL="${OVR_PTOL} -Fgenerate_sync_arcs=no"
      fi;
      OPT_IPA=0;
    fi

    if [ $OPT_IPA -eq 1 ]; then
       Announce "> c2gp 6/6:  Converting Pcode to Lcode (w/ sync arcs)"
    else
       Announce "> c2gp 6/6:  Converting Pcode to Lcode (no sync arcs)"
    fi

    # Invoke PIP (pointer analysis), if desired
    if [ $OPT_IPA -eq 1 ]; then

       echo "> Pipa -i a.out.pci -o stp";
       Pipa -i a.out.pci -o stp;
       Check "$?"

       CB_remove_unless pci

       echo "> Protate -i a.out.stp";
       Protate -i a.out.stp;
       Check "$?"

       if [ $OPT_DO_OMEGA -eq 1 ]; then
          echo "> Pomega -i a.out.stp -o stp_w";
          Pomega -i a.out.stp -o stp_w;
          Check "$?"
       fi

       if [ $OPT_DO_OMEGA -eq 1 ]; then 
         echo "PtoL -i a.out.stp_w"
         PtoL -i a.out.stp_w  -Fgen_acc_specs=yes ${OVR_PTOL}
         Check "$?"

         CB_tar_up stp_w
         CB_remove_unless stp_w
       else
         echo "PtoL -i a.out.stp"
         PtoL -i a.out.stp  -Fgen_acc_specs=yes ${OVR_PTOL}
         Check "$?"

         CB_tar_up stp
         CB_remove_unless stp
       fi

    # Otherwise, use old path (no pointer analysis)
    else
       $BEGIN_SETX
       echo PtoL -i a.out.pci -Fgenerate_sync_arcs=no ${OVR_PTOL}
       PtoL -i a.out.pci -Fgenerate_sync_arcs=no ${OVR_PTOL}
       Check "$?"
       $END_SETX

       CB_remove_unless pci

    fi

    cp ${IMPACT_REL_PATH}/platform/${IMPACT_HOST_PLATFORM}_${IMPACT_HOST_COMPILER}/host_layout_info.md .
    Check "$?"

    ${RM} impactlist~$$;
    if [ $NOCLEAN -ne 1 ]; then
       ${RM} impact_aggregate.dat impact_global.dat impact_vararg;
    fi

    if [ $OPT_DO_SSA -eq 1 ]; then
       gen_generic Lssaopti -in lc -out lcx
       for F in *.lcx ; do mv $F ${F%%.lcx}.lc ; done
    fi;

    CB_tar_up lc
    CB_remove_unless lc $DO_lc2O
fi

############################################################################
#    The lc2O compilation segment
############################################################################
if [ $DO_lc2O -eq 1 ]; then

    Announce "lc2O:  Running Lopti on .lc files"

    CB_restore_unless lc $DO_fe_5

    ${LS} *.lc > impactlist~$$;
    Check "$?"

    $BEGIN_SETX
    ${TIME} gen_Lopti . IMPACT Lcode 4 "${OVR_LOPTI}" < impactlist~$$;
    Check "$?"
    $END_SETX
    
    CB_remove_unless lc

    CB_tar_up O

    CB_remove_unless O $DO_O2O_im_p $DO_O2O_tr $DO_O2O_p
    ${RM} impactlist~$$;
fi

############################################################################
#    The O2O_p compilation segment
############################################################################

DO_O2O_p=0

if [ $DO_O2O_p -eq 1 ]; then

    Announce "O2O_p: Profiling .O files"

    CB_restore_unless O $DO_lc2O

    ${RM} *.O_p

    $BEGIN_SETX
    ${TIME} gen_profiled_lcode . $READ_PATHS $PROFILE_OPTIONS \
        -ext O -loop_iters \
        $LPROF_INPUT_CMD "$TRAIN_LIST" \
        $SETUP_CMD "$SETUP_TEXT" $CPREFIX_CMD "$CPREFIX_TEXT" \
        $ARGS_CMD "$ARGS_TEXT" $CHECK_CMD "$CHECK_TEXT" \
        $CLEANUP_CMD "$CLEANUP_TEXT";
    Check "$?"
    $END_SETX

    CB_remove_unless O $DO_O2O_im_p

    CB_tar_up O_p

    CB_remove_unless O_p $DO_O_p2S $DO_O_p2H
fi

############################################################################
#    The O2O_im_p compilation segment
############################################################################
if [ $DO_O2O_im_p -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%%";
    echo "> O2O_im_p segment: Scheduling and register allocating .O files + statistics"
    echo " ";
    rm -f *.O_im

    CB_restore_unless O $DO_lc2O

    ls *.O > impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $BEGIN_SETX
    ${TIME} gen_Limpact . Lcode O_im "${OVR_LIMPACT}" < impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $END_SETX

    rm -f impactlist;

    if [ $NOCLEAN -eq 1 ]; then
        echo " ";
        gen_tar ${BASENAME} O_im;
        if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    fi

    # Static analysis info invalid, since profile info corrupt due to opti
    rm -f IMPACT_001;

    CB_remove_unless O $DO_O2O_tr $DO_O_p2S $DO_O_p2H

    echo " ";
    echo '> Profiling final "assembly" to verify output correctness and'
    echo '> to generate a profile-based static performance estimate for each eval input'
    echo " ";
    rm -f *.O_im_p

    $BEGIN_SETX
    ${TIME} gen_profiled_lcode . $READ_PATHS $PROFILE_OPTIONS \
        -ext O_im -stats -debug \
        $LPROF_INPUT_CMD "$TRAIN_LIST" \
        $SETUP_CMD "$SETUP_TEXT" $CPREFIX_CMD "$CPREFIX_TEXT" \
        $ARGS_CMD "$ARGS_TEXT" $CHECK_CMD "$CHECK_TEXT" \
        $CLEANUP_CMD "$CLEANUP_TEXT";
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    $END_SETX

    rm -f *.O_im

    echo " ";
    gen_tar ${BASENAME} O_im_p;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    CB_remove_unless O_im_p $DO_O_im_p2O_im_p_sim
fi

############################################################################
#    The O_im_p2O_im_p.sim segment
############################################################################
if [ $DO_O_im_p2O_im_p_sim -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%%";
    echo "> O_im_p2O_im_p.sim segment: Full system simulation of .O_im_p files"
    echo " ";

    CB_restore_unless O_im_p $DO_O2O_im_p

    echo " ";
    $BEGIN_SETX
    ${TIME} sim_bench $BASENAME O_im_p $READ_PATHS $SIM_OPTIONS \
	$SIM_PARMS_SETTING \
        $SIM_INPUT_CMD "$EVAL_LIST" \
        $SETUP_CMD "$SETUP_TEXT" $CPREFIX_CMD "$CPREFIX_TEXT" \
        $ARGS_CMD "$ARGS_TEXT" $CHECK_CMD "$CHECK_TEXT" \
        $CLEANUP_CMD "$CLEANUP_TEXT";
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    $END_SETX

    # Remove .O_im_p files 
    rm -f *.O_im_p;
fi

############################################################################
#    The O2O_tr compilation segment
############################################################################
if [ $DO_O2O_tr -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%%";
    echo "> O2O_tr segment: Converting .O_p files to .O_tr (Trimaran bridge code)"
    echo " ";
    rm -f *.O_tr

    CB_restore_unless O

    ls *.O > impactlist;

    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    # Use "unsafe" flag-based sync arcs that Lhpl_pd automatically generates.
    # Run only phase O_tr(1) to get .O_tr files with the generated sync-arcs.
    $BEGIN_SETX
    ${TIME} gen_Lhpl_pd . V1.0 O_tr "${OVR_LHPL_PD}" < impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $END_SETX

    CB_remove_unless O $DO_O_p2S $DO_O_p2H

    echo " ";
    gen_tar ${BASENAME} O_tr;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    rm -f *.O_tr
    rm -f impactlist;
fi

###########################################################################
#    The O_p2S compilation segment
############################################################################
if [ $DO_O_p2S -eq 1 ]; then

    Announce "O_p2S:  Running Lsuperscalar on .O files";

    ${RM} *.S

    CB_restore_unless O_p $DO_O2O_p

    ${LS} *.O_p > impactlist~$$;
    Check "$?"

    $BEGIN_SETX
    FLG_LSUPER="-Fcombine_exits=no ${OVR_LOPTI} ${OVR_LSUPER}"
    ${TIME} gen_Lsuperscalar . IMPACT Lcode "${FLG_LSUPER}" < impactlist~$$;
    Check "$?"
    $END_SETX

    CB_tar_up S

    ${RM} impactlist~$$;

    CB_remove_unless O_p $DO_O_p2H
    
    CB_remove_unless S $DO_S2S_im_p $DO_S2S_tr
fi

############################################################################
#    The S2S_im_p compilation segment
############################################################################
if [ $DO_S2S_im_p -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%%";
    echo "> S2S_im_p segment: Scheduling and register allocating .S files + statistics"
    echo " ";
    rm -f *.S_im

    CB_restore_unless S $DO_O_p2S

    ls *.S > impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $BEGIN_SETX
    ${TIME} gen_Limpact . Lcode S_im "${OVR_LIMPACT}" < impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $END_SETX

    rm -f impactlist;

    if [ $NOCLEAN -eq 1 ]; then
        echo " ";
        gen_tar ${BASENAME} S_im;
        if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    fi

    # Static analysis info invalid, since profile info corrupt due to opti
    rm -f IMPACT_001;

    CB_remove_unless S $DO_S2S_tr

    echo " ";
    echo '> Profiling final "assembly" to verify output correctness and'
    echo '> to generate a profile-based static performance estimate for each eval input'
    echo " ";
    rm -f *.S_im_p

    $BEGIN_SETX
    ${TIME} gen_profiled_lcode . $READ_PATHS $PROFILE_OPTIONS \
        -ext S_im -stats $LPROF_INPUT_CMD "$EVAL_LIST" \
        $SETUP_CMD "$SETUP_TEXT" $CPREFIX_CMD "$CPREFIX_TEXT" \
        $ARGS_CMD "$ARGS_TEXT" $CHECK_CMD "$CHECK_TEXT" \
        $CLEANUP_CMD "$CLEANUP_TEXT";
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    $END_SETX

    rm -f *.S_im

    echo " ";
    gen_tar ${BASENAME} S_im_p;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    CB_remove_unless S_im_p $DO_S_im_p2S_im_p_sim
fi

############################################################################
#    The S_im_p2S_im_p.sim segment
############################################################################
if [ $DO_S_im_p2S_im_p_sim -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%%";
    echo "> S_im_p2S_im_p.sim segment: Full system simulation of .S_im_p files"
    echo " ";

    CB_restore_unless S_im_p $DO_S2S_im_p

    if [ $OPT_SPECTR -eq 1 ]; then
        echo "> Renumbering SPECIDs ";
        S_MAX_SPECID=`RenumSPECIDs *.S_im_p`;
	let "S_SPECIDS = S_MAX_SPECID + 1"
        gen_tar ${BASENAME} S_im_p;
        SIM_OPTIONS="${SIM_OPTIONS} -Fmax_specid=${S_MAX_SPECID} -Fsq_spec_load_tags=${S_SPECIDS}"
    fi;

    echo " ";
    $BEGIN_SETX
    ${TIME} sim_bench $BASENAME S_im_p $READ_PATHS $SIM_OPTIONS \
        $SIM_INPUT_CMD "$EVAL_LIST" \
        $SETUP_CMD "$SETUP_TEXT" $CPREFIX_CMD "$CPREFIX_TEXT" \
        $ARGS_CMD "$ARGS_TEXT" $CHECK_CMD "$CHECK_TEXT" \
        $CLEANUP_CMD "$CLEANUP_TEXT";
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    $END_SETX

    # Remove .S_im_p files 
    rm -f *.S_im_p;
fi

############################################################################
#    The S2S_tr compilation segment
############################################################################
if [ $DO_S2S_tr -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%";
    echo "> S2S_tr segment: Converting .S files to .S_tr (Trimaran bridge code)"
    echo " ";
    rm -f *.S_tr

    CB_restore_unless S $DO_O_p2S

    ls *.S > impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    # Use "unsafe" flag-based sync arcs that Lhpl_pd automatically generates.
    # Run only phase S_tr(1) to get .S_tr files with the generated sync-arcs.
    $BEGIN_SETX
    ${TIME} gen_Lhpl_pd . V1.0 S_tr "${OVR_LHPL_PD}" < impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $END_SETX

    rm -f *.S;

    echo " ";
    gen_tar ${BASENAME} S_tr;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    rm -f *.S_tr
    rm -f impactlist;
fi

############################################################################
#    Part 1 of 2 of the O_p2HS compilation segment
#    Create hyperblocks using Lblock
############################################################################
if [ $DO_O_p2H -eq 1 ]; then

    Announce "O_p2H: Running Lblock on .O files to create hyperblocks"

    ${RM} *.H

    CB_restore_unless O_p $DO_O2O_p

    ${LS} *.O_p > impactlist~$$;
    Check "$?"

    if [ $OPT_DO_SSA -eq 1 ]; then
        gen_generic Lssaopti -out X < impactlist~$$;
        Check "$?"

	CB_tar_up X
        ${LS} *.X > impactlist~$$;
        Check "$?"
    fi

    $BEGIN_SETX
    ${TIME} gen_Lblock . IMPACT Lcode "${OVR_LOPTI} \
	${OVR_LBLOCK}" < impactlist~$$;
    Check "$?"
    $END_SETX

    ${RM} impactlist~$$;
    ${RM} *.O_p;

    if [ $OPT_DO_SSA -eq 1 ]; then
        ${RM} *.X;
    fi

    if [ $OPT_IND_ANAL -eq 0 ]; then
	CB_tar_up H
    else
	echo "> Processing H files using Linduct";
	gen_Linduct ${BASENAME} H;
	Check "$?"
    fi
    CB_remove_unless H $DO_H2HS
fi

############################################################################
#    Part 2 of 2 of the O_p2HS compilation segment
#    ILP optimize hyperblocks using Lsuperscalar
############################################################################

if [ $DO_H2HS -eq 1 ]; then

    Announce "H2HS: Running Lsuperscalar on .H files"

    ${RM} *.HS

    CB_restore_unless H $DO_O_p2H

    ${LS} *.H > impactlist~$$;
    Check "$?"

    $BEGIN_SETX
    FLG_LSUPER="-Fdo_branch_combining=yes -Fpred_exec_support=yes -Fcombine_exits=no ${OVR_LOPTI} ${OVR_LSUPER}";
    ${TIME} gen_LsuperscalarH . IMPACT Lcode "${FLG_LSUPER}" < impactlist~$$;
    Check "$?"
    $END_SETX

    ${RM} impactlist~$$;
    ${RM} *.H;

    if [ $OPT_IND_ANAL -eq 0 ]; then
	CB_tar_up HS
    else
	echo "> Processing HS files using Linduct";
	gen_Linduct ${BASENAME} HS;
	Check "$?"
    fi

    CB_remove_unless HS $DO_HS2HS_im_p $DO_HS2HS_tr $DO_HS2HSP
fi

############################################################################
#    Program Decision Logic Optimization
#    JWS 19991130
############################################################################
if [ $DO_HS2HSP -eq 1 ]; then
    echo " ";
    echo "> %%%%%%%%%%";
    echo "> HS2HSP segment: ";
    echo " ";

    CB_restore_unless HS $DO_H2HS

    $BEGIN_SETX
    gen_generic Lpred_opti -in HS -out HSP "-Finfinite_issue=yes"
    $END_SETX

    gen_tar ${BASENAME} HSP;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    CB_remove_unless HSP $DO_HS2HS_im_p
fi

############################################################################
#    The HS2HS_im_p compilation segment
############################################################################
if [ $DO_HS2HS_im_p -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%%";
    echo "> HS2HS_im_p segment: Scheduling and register allocating .HS files + statistics"
    echo " ";
    rm -f *.HS_im

    if [ $DO_LPO -eq 1 ]; then
        BASE=HSP;
    else
	BASE=HS;
    fi

    # Restore HS files, if necessary
    if [ $DO_LPO -eq 0 ]; then
        if [ $DO_H2HS -eq 0 ]; then
           rm -f *.${BASE};
           gen_untar ${BASENAME} ${BASE};
           if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
           echo " ";
        fi
    else 
        if [ $DO_HS2HSP -eq 0 ]; then
           rm -f *.${BASE};
           gen_untar ${BASENAME} ${BASE};
           if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
           echo " ";	    
        fi
    fi

    ls *.${BASE} > impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $BEGIN_SETX
    ${TIME} gen_Limpact . Lcode ${BASE}_im "${OVR_LIMPACT}" < impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $END_SETX

    rm -f impactlist;

    if [ $NOCLEAN -eq 1 ]; then
        echo " ";
        gen_tar ${BASENAME} ${BASE}_im;
        if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    fi

    # Static analysis info invalid, since profile info corrupt due to opti
    rm -f IMPACT_001;

    CB_remove_unless ${BASE} $DO_HS2HS_tr

    echo " ";
    echo '> Profiling final "assembly" to verify output correctness and'
    echo '> to generate a profile-based static performance estimate for each eval input'
    echo " ";
    rm -f *.${BASE}_im_p

    $BEGIN_SETX
    ${TIME} gen_profiled_lcode . $READ_PATHS $PROFILE_OPTIONS \
        -ext ${BASE}_im -stats \
        $LPROF_INPUT_CMD "$EVAL_LIST" \
        $SETUP_CMD "$SETUP_TEXT" $CPREFIX_CMD "$CPREFIX_TEXT" \
        $ARGS_CMD "$ARGS_TEXT" $CHECK_CMD "$CHECK_TEXT" \
        $CLEANUP_CMD "$CLEANUP_TEXT";
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    $END_SETX

    rm -f *.${BASE}_im

    echo " ";
    gen_tar ${BASENAME} ${BASE}_im_p;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    CB_remove_unless ${BASE}_im_p $DO_HS_im_p2HS_im_p_sim
fi

############################################################################
#    The HS_im_p2HS_im_p.sim segment
############################################################################
if [ $DO_HS_im_p2HS_im_p_sim -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%%";
    echo "> HS_im_p2HS_im_p.sim segment: Full system simulation of .HS_im_p files"
    echo " ";

    # Restore HS_im_p files, if necessary
    if [ $DO_HS2HS_im_p -eq 0 ]; then
        rm -f *.HS_im_p;
        gen_untar ${BASENAME} HS_im_p;
        if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
        echo " ";
    fi

    if [ $OPT_SPECTR -eq 1 ]; then
        echo "> Renumbering SPECIDs ";
        S_MAX_SPECID=`RenumSPECIDs *.HS_im_p`;
	let "S_SPECIDS = S_MAX_SPECID + 1"
	echo "> Using SPECIDs 0..${S_MAX_SPECID}"
        gen_tar ${BASENAME} HS_im_p;
        SIM_OPTIONS="${SIM_OPTIONS} -Fmax_specid=${S_MAX_SPECID} -Fsq_spec_load_tags=${S_SPECIDS}"
    fi;

    echo " ";
    $BEGIN_SETX
    ${TIME} sim_bench $BASENAME HS_im_p $READ_PATHS $SIM_OPTIONS \
        $SIM_INPUT_CMD "$EVAL_LIST" \
        $SETUP_CMD "$SETUP_TEXT" $CPREFIX_CMD "$CPREFIX_TEXT" \
        $ARGS_CMD "$ARGS_TEXT" $CHECK_CMD "$CHECK_TEXT" \
        $CLEANUP_CMD "$CLEANUP_TEXT";
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
    $END_SETX

    # Remove .HS_im_p files 
    rm -f *.HS_im_p;
fi

############################################################################
#    The HS2HS_tr compilation segment
############################################################################
if [ $DO_HS2HS_tr -eq 1 ]; then

    echo " ";
    echo "> %%%%%%%%%%";
    echo "> HS2HS_tr segment: Converting .HS files to .HS_tr (Trimaran bridge code)"
    echo " ";
    rm -f *.HS_tr

    # Restore HS files, if necessary
    if [ $DO_H2HS -eq 0 ]; then
        rm -f *.HS;
        gen_untar ${BASENAME} HS;
        if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi
        echo " ";
    fi

    ls *.HS > impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    # Use "unsafe" flag-based sync arcs that Lhpl_pd automatically generates.
    # Run only phase HS_tr(1) to get .HS_tr files with the generated sync-arcs.
    $BEGIN_SETX
    ${TIME} gen_Lhpl_pd . V1.0 HS_tr "${OVR_LHPL_PD}" < impactlist;
    if test "$?" != 0; then echo "Exiting: non-zero exit code"; exit 1;fi
    $END_SETX

    rm -f *.HS;

    echo " ";
    gen_tar ${BASENAME} HS_tr;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    rm -f *.HS_tr
    rm -f impactlist;
fi

############################################################################
#    Generate Store Sets
#    MCM 02/05/2002
############################################################################
if [ $DO_O_im_p2O_im_p_ss -eq 1 ]; then
    echo " ";
    echo "> %%%%%%%%%%";
    echo "> O_im_p2O_im_p_s segment: ";
    echo " ";

    CB_restore_unless O_im_p

    $BEGIN_SETX
    Lass -Ffile_processing_model=extension -Finput_file_extension=O_im_p
    $END_SETX

    gen_tar ${BASENAME} O_im_p_ss;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    CB_remove_unless O_im_p_ss
    CB_remove_unless O_im_p
fi

if [ $DO_HS_im_p2HS_im_p_ss -eq 1 ]; then
    echo " ";
    echo "> %%%%%%%%%%";
    echo "> HS_im_p2HS_im_p_s segment: ";
    echo " ";

    CB_restore_unless HS_im_p

    $BEGIN_SETX
    Lass -Ffile_processing_model=extension -Finput_file_extension=HS_im_p
    $END_SETX

    gen_tar ${BASENAME} HS_im_p_ss;
    if test "$?" != 0; then echo "Exiting: non-zero exit code";exit 1;fi

    CB_remove_unless HS_im_p_ss
    CB_remove_unless HS_im_p
fi

############################################################################
#       Done, whew!
############################################################################

   END_DATE=`date +"%T %D"`;
   echo " "
   echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%";
   echo "> Finished 'compile_bench ${COMPILE_BENCH_ARGS}'";
   echo "> Processed ${BASENAME} from $START_DATE to $END_DATE";
   echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%";
