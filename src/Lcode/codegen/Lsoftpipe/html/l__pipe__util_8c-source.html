<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsoftpipe: l_pipe_util.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>l_pipe_util.c</h1><a href="l__pipe__util_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*****************************************************************************\</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> *                    Illinois Open Source License</span>
<a name="l00004"></a>00004 <span class="comment"> *                     University of Illinois/NCSA</span>
<a name="l00005"></a>00005 <span class="comment"> *                         Open Source License</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * Copyright (c) 2004, The University of Illinois at Urbana-Champaign.</span>
<a name="l00008"></a>00008 <span class="comment"> * All rights reserved.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * Developed by:             </span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *              IMPACT Research Group</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *              University of Illinois at Urbana-Champaign</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> *              http://www.crhc.uiuc.edu/IMPACT</span>
<a name="l00017"></a>00017 <span class="comment"> *              http://www.gelato.org</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * Permission is hereby granted, free of charge, to any person</span>
<a name="l00020"></a>00020 <span class="comment"> * obtaining a copy of this software and associated documentation</span>
<a name="l00021"></a>00021 <span class="comment"> * files (the "Software"), to deal with the Software without</span>
<a name="l00022"></a>00022 <span class="comment"> * restriction, including without limitation the rights to use, copy,</span>
<a name="l00023"></a>00023 <span class="comment"> * modify, merge, publish, distribute, sublicense, and/or sell copies</span>
<a name="l00024"></a>00024 <span class="comment"> * of the Software, and to permit persons to whom the Software is</span>
<a name="l00025"></a>00025 <span class="comment"> * furnished to do so, subject to the following conditions:</span>
<a name="l00026"></a>00026 <span class="comment"> *</span>
<a name="l00027"></a>00027 <span class="comment"> * Redistributions of source code must retain the above copyright</span>
<a name="l00028"></a>00028 <span class="comment"> * notice, this list of conditions and the following disclaimers.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Redistributions in binary form must reproduce the above copyright</span>
<a name="l00031"></a>00031 <span class="comment"> * notice, this list of conditions and the following disclaimers in</span>
<a name="l00032"></a>00032 <span class="comment"> * the documentation and/or other materials provided with the</span>
<a name="l00033"></a>00033 <span class="comment"> * distribution.</span>
<a name="l00034"></a>00034 <span class="comment"> *</span>
<a name="l00035"></a>00035 <span class="comment"> * Neither the names of the IMPACT Research Group, the University of</span>
<a name="l00036"></a>00036 <span class="comment"> * Illinois, nor the names of its contributors may be used to endorse</span>
<a name="l00037"></a>00037 <span class="comment"> * or promote products derived from this Software without specific</span>
<a name="l00038"></a>00038 <span class="comment"> * prior written permission.  THE SOFTWARE IS PROVIDED "AS IS",</span>
<a name="l00039"></a>00039 <span class="comment"> * WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT</span>
<a name="l00040"></a>00040 <span class="comment"> * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A</span>
<a name="l00041"></a>00041 <span class="comment"> * PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE</span>
<a name="l00042"></a>00042 <span class="comment"> * CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES</span>
<a name="l00043"></a>00043 <span class="comment"> * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<a name="l00044"></a>00044 <span class="comment"> * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE</span>
<a name="l00045"></a>00045 <span class="comment"> * OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.</span>
<a name="l00046"></a>00046 <span class="comment"> *</span>
<a name="l00047"></a>00047 <span class="comment">\*****************************************************************************/</span>
<a name="l00048"></a>00048 <span class="comment">/*****************************************************************************\</span>
<a name="l00049"></a>00049 <span class="comment"> *      File: l_pipe_util.c</span>
<a name="l00050"></a>00050 <span class="comment"> *      Description: Queue routines and other general purpose routines</span>
<a name="l00051"></a>00051 <span class="comment"> *      Creation Date: January, 1994</span>
<a name="l00052"></a>00052 <span class="comment"> *      Author: Daniel Lavery</span>
<a name="l00053"></a>00053 <span class="comment"> *</span>
<a name="l00054"></a>00054 <span class="comment"> *      Revision Date: Summer 1999</span>
<a name="l00055"></a>00055 <span class="comment"> *      Authors: IMPACT Technologies: Matthew Merten and John Gyllenhaal</span>
<a name="l00056"></a>00056 <span class="comment">\*****************************************************************************/</span>
<a name="l00057"></a>00057 <span class="comment">/* 09/19/02 REK Updating to use functions from ltahoe_op_query.h instead</span>
<a name="l00058"></a>00058 <span class="comment"> *              of Tmdes. */</span>
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="comment">/* 10/29/02 REK Adding config.h */</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;config.h&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include "<a class="code" href="l__softpipe__int_8h.html">l_softpipe_int.h</a>"</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;Lcode/r_regalloc.h&gt;</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="comment">/*************************************************************************</span>
<a name="l00066"></a>00066 <span class="comment">                Global Variables</span>
<a name="l00067"></a>00067 <span class="comment">*************************************************************************/</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/* alloc pools for queues and queue nodes */</span>
<a name="l00070"></a><a class="code" href="l__pipe__util_8h.html#4a9d1f680824f7426e01b910d4cc2b03">00070</a> L_Alloc_Pool *<a class="code" href="l__pipe__util_8c.html#4a9d1f680824f7426e01b910d4cc2b03">Queue_pool</a> = NULL;
<a name="l00071"></a><a class="code" href="l__pipe__util_8h.html#b2b35dba38efd9d6e53512e38d014729">00071</a> L_Alloc_Pool *<a class="code" href="l__pipe__util_8c.html#b2b35dba38efd9d6e53512e38d014729">Qnode_pool</a> = NULL;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="comment">/*************************************************************************</span>
<a name="l00074"></a>00074 <span class="comment">                Lsoftpipe Global Parameter Declarations</span>
<a name="l00075"></a>00075 <span class="comment">*************************************************************************/</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="comment">/* parameters - see l_pipe_util.h */</span>
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="l__pipe__util_8h.html#fe93aca3da93bf91019df7f7726355fb">00079</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#fe93aca3da93bf91019df7f7726355fb">Lpipe_do_induction_reversal</a> = 0;
<a name="l00080"></a><a class="code" href="l__pipe__util_8h.html#6535802484914fea24cb0c4267280e86">00080</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#6535802484914fea24cb0c4267280e86">Lpipe_check_loops_in_phase1</a> = 1;
<a name="l00081"></a>00081 
<a name="l00082"></a><a class="code" href="l__pipe__util_8h.html#659205866ba47e73cc85c2376ecd1985">00082</a> <span class="keywordtype">char</span> *<a class="code" href="l__pipe__util_8c.html#659205866ba47e73cc85c2376ecd1985">Lpipe_schema_name</a> = NULL;
<a name="l00083"></a><a class="code" href="l__pipe__util_8h.html#9929661b757af9845e6325f4752a7d87">00083</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#9929661b757af9845e6325f4752a7d87">Lpipe_schema</a> = <a class="code" href="l__pipe__util_8h.html#50a9671342717fc27f66fbb4178f4827">MULTI_EPI</a>;
<a name="l00084"></a>00084 
<a name="l00085"></a><a class="code" href="l__pipe__util_8h.html#1ed5180823f3e497dbc3becd928690f5">00085</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#1ed5180823f3e497dbc3becd928690f5">Lpipe_backward_sched</a> = 1;
<a name="l00086"></a>00086 
<a name="l00087"></a><a class="code" href="l__pipe__util_8h.html#a50c2551f678955eabc6e79793268ffa">00087</a> <span class="keywordtype">float</span> <a class="code" href="l__pipe__util_8c.html#a50c2551f678955eabc6e79793268ffa">Lpipe_budget_ratio</a> = 5.0;
<a name="l00088"></a><a class="code" href="l__pipe__util_8h.html#05fca7cb5ae9510942db3f6c0307a355">00088</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#05fca7cb5ae9510942db3f6c0307a355">Lpipe_min_ii</a> = 0;           <span class="comment">/* 0 is no minimum. */</span>
<a name="l00089"></a><a class="code" href="l__pipe__util_8h.html#971e2f43a9bcf87d02ca3adb1f632358">00089</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#971e2f43a9bcf87d02ca3adb1f632358">Lpipe_max_ii</a> = 1000;
<a name="l00090"></a><a class="code" href="l__pipe__util_8h.html#d36c8bdff7baceb8d1cb7853c908bf03">00090</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#d36c8bdff7baceb8d1cb7853c908bf03">Lpipe_max_stages</a> = 1000;
<a name="l00091"></a><a class="code" href="l__pipe__util_8h.html#b20efb4ff31868be5a5b0c3039351158">00091</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#b20efb4ff31868be5a5b0c3039351158">Lpipe_max_tries</a> = 50;
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="l__pipe__util_8h.html#5dfc4a9a1248286c8e15ad45456ddb90">00093</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#5dfc4a9a1248286c8e15ad45456ddb90">Lpipe_fixed_slots_for_branches</a> = 0;
<a name="l00094"></a><a class="code" href="l__pipe__util_8h.html#414f010c3e4a932c6061bb593e7945b0">00094</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#414f010c3e4a932c6061bb593e7945b0">Lpipe_do_only_postpass_steps</a> = 0;
<a name="l00095"></a>00095 
<a name="l00096"></a><a class="code" href="l__pipe__util_8h.html#86f23e88bb2635324fa313d64bb50971">00096</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#86f23e88bb2635324fa313d64bb50971">Lpipe_compact_branch_path_opers</a> = 0;
<a name="l00097"></a><a class="code" href="l__pipe__util_8h.html#1fd08397fdb9c8be171e9e45a1d811aa">00097</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#1fd08397fdb9c8be171e9e45a1d811aa">Lpipe_sort_mrt_rows</a> = 1;
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="l__pipe__util_8h.html#33aa768a71f08754b1273f95c0cf1d2f">00099</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#33aa768a71f08754b1273f95c0cf1d2f">Lpipe_combine_cbs</a> = 1;
<a name="l00100"></a>00100 
<a name="l00101"></a><a class="code" href="l__pipe__util_8h.html#ad83dd0fea79c90886829873235d97be">00101</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#ad83dd0fea79c90886829873235d97be">Lpipe_debug</a> = 0;
<a name="l00102"></a><a class="code" href="l__pipe__util_8h.html#ab570eb13a3e6d913d45c8a3b85fad84">00102</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#ab570eb13a3e6d913d45c8a3b85fad84">Lpipe_debug_use_cb_bounds</a> = 0;
<a name="l00103"></a><a class="code" href="l__pipe__util_8h.html#4ebe475f1a840fbaa32b10d000fd7f70">00103</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#4ebe475f1a840fbaa32b10d000fd7f70">Lpipe_debug_lower_cb_bound</a> = 0;
<a name="l00104"></a><a class="code" href="l__pipe__util_8h.html#9142d5510348648db05b36ee12f6058e">00104</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#9142d5510348648db05b36ee12f6058e">Lpipe_debug_upper_cb_bound</a> = 100000000;
<a name="l00105"></a><a class="code" href="l__pipe__util_8h.html#ab2140575cdf9b3526e6da5ea095a784">00105</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#ab2140575cdf9b3526e6da5ea095a784">Lpipe_print_statistics</a> = 0;
<a name="l00106"></a><a class="code" href="l__pipe__util_8h.html#f65026de9f77648de4df3b4f4ec74417">00106</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#f65026de9f77648de4df3b4f4ec74417">Lpipe_print_iteration_schedule</a> = 0;
<a name="l00107"></a><a class="code" href="l__pipe__util_8h.html#0b64713f1a54406156072dd81814ea25">00107</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#0b64713f1a54406156072dd81814ea25">Lpipe_print_schedules_for_debug</a> = 0;
<a name="l00108"></a><a class="code" href="l__pipe__util_8h.html#39d6ce980c9450094cb1c9372292b9ac">00108</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#39d6ce980c9450094cb1c9372292b9ac">Lpipe_print_mve_summary</a> = 0;
<a name="l00109"></a>00109 
<a name="l00110"></a><a class="code" href="l__pipe__util_8h.html#05b449c92ca8c59d61db6054cd56e7ee">00110</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#05b449c92ca8c59d61db6054cd56e7ee">Lpipe_compute_loop_reg_pressure</a> = 0;
<a name="l00111"></a><a class="code" href="l__pipe__util_8h.html#e2d1368da174d6c3c8b7ec7d1cbbf44e">00111</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#e2d1368da174d6c3c8b7ec7d1cbbf44e">Lpipe_add_spill_attributes</a> = 0;
<a name="l00112"></a>00112 
<a name="l00113"></a><a class="code" href="l__pipe__util_8h.html#2b86b75abb1973402ba2363621a03bb3">00113</a> <span class="keywordtype">int</span> <a class="code" href="l__pipe__util_8c.html#2b86b75abb1973402ba2363621a03bb3">Lpipe_dump_dot</a> = 0;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="comment">/*************************************************************************</span>
<a name="l00116"></a>00116 <span class="comment">                Initialization Function Definitions</span>
<a name="l00117"></a>00117 <span class="comment">*************************************************************************/</span>
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">/* Read parameters from Softpipe section */</span>
<a name="l00120"></a>00120 <span class="comment">/* see l_pipe_util.h for parm descriptions */</span>
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keywordtype">void</span>
<a name="l00123"></a><a class="code" href="l__pipe__util_8h.html#38ba5bc4aa0dd1d12f1f16934a3137b1">00123</a> <a class="code" href="l__pipe__util_8c.html#6f5aa25c2a95b94ee73ac1b754207d70">L_read_parm_lpipe</a> (Parm_Parse_Info * ppi)
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125   L_read_parm_b (ppi, <span class="stringliteral">"do_induction_reversal"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#fe93aca3da93bf91019df7f7726355fb">Lpipe_do_induction_reversal</a>);
<a name="l00126"></a>00126   L_read_parm_b (ppi, <span class="stringliteral">"check_loops_in_phase1"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#6535802484914fea24cb0c4267280e86">Lpipe_check_loops_in_phase1</a>);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   L_read_parm_s (ppi, <span class="stringliteral">"code_schema"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#659205866ba47e73cc85c2376ecd1985">Lpipe_schema_name</a>);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   L_read_parm_b (ppi, <span class="stringliteral">"backward_scheduling"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#1ed5180823f3e497dbc3becd928690f5">Lpipe_backward_sched</a>);
<a name="l00131"></a>00131   L_read_parm_f (ppi, <span class="stringliteral">"budget_ratio"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#a50c2551f678955eabc6e79793268ffa">Lpipe_budget_ratio</a>);
<a name="l00132"></a>00132   L_read_parm_i (ppi, <span class="stringliteral">"softpipe_min_ii"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#05fca7cb5ae9510942db3f6c0307a355">Lpipe_min_ii</a>);
<a name="l00133"></a>00133   L_read_parm_i (ppi, <span class="stringliteral">"softpipe_max_ii"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#971e2f43a9bcf87d02ca3adb1f632358">Lpipe_max_ii</a>);
<a name="l00134"></a>00134   L_read_parm_i (ppi, <span class="stringliteral">"softpipe_max_stages"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#d36c8bdff7baceb8d1cb7853c908bf03">Lpipe_max_stages</a>);
<a name="l00135"></a>00135   L_read_parm_i (ppi, <span class="stringliteral">"softpipe_max_tries"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#b20efb4ff31868be5a5b0c3039351158">Lpipe_max_tries</a>);
<a name="l00136"></a>00136   L_read_parm_b (ppi, <span class="stringliteral">"fixed_slots_for_branches"</span>,
<a name="l00137"></a>00137                  &amp;<a class="code" href="l__pipe__util_8c.html#5dfc4a9a1248286c8e15ad45456ddb90">Lpipe_fixed_slots_for_branches</a>);
<a name="l00138"></a>00138   L_read_parm_b (ppi, <span class="stringliteral">"?do_only_postpass_steps"</span>,
<a name="l00139"></a>00139                  &amp;<a class="code" href="l__pipe__util_8c.html#414f010c3e4a932c6061bb593e7945b0">Lpipe_do_only_postpass_steps</a>);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   L_read_parm_b (ppi, <span class="stringliteral">"compact_branch_path_opers"</span>,
<a name="l00142"></a>00142                  &amp;<a class="code" href="l__pipe__util_8c.html#86f23e88bb2635324fa313d64bb50971">Lpipe_compact_branch_path_opers</a>);
<a name="l00143"></a>00143   L_read_parm_b (ppi, <span class="stringliteral">"sort_mrt_rows"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#1fd08397fdb9c8be171e9e45a1d811aa">Lpipe_sort_mrt_rows</a>);
<a name="l00144"></a>00144   L_read_parm_b (ppi, <span class="stringliteral">"softpipe_combine_cbs"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#33aa768a71f08754b1273f95c0cf1d2f">Lpipe_combine_cbs</a>);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   L_read_parm_i (ppi, <span class="stringliteral">"debug_software_pipelining"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#ad83dd0fea79c90886829873235d97be">Lpipe_debug</a>);
<a name="l00147"></a>00147   L_read_parm_b (ppi, <span class="stringliteral">"softpipe_debug_use_cb_bounds"</span>,
<a name="l00148"></a>00148                  &amp;<a class="code" href="l__pipe__util_8c.html#ab570eb13a3e6d913d45c8a3b85fad84">Lpipe_debug_use_cb_bounds</a>);
<a name="l00149"></a>00149   L_read_parm_i (ppi, <span class="stringliteral">"softpipe_debug_lower_cb_bound"</span>,
<a name="l00150"></a>00150                  &amp;<a class="code" href="l__pipe__util_8c.html#4ebe475f1a840fbaa32b10d000fd7f70">Lpipe_debug_lower_cb_bound</a>);
<a name="l00151"></a>00151   L_read_parm_i (ppi, <span class="stringliteral">"softpipe_debug_upper_cb_bound"</span>,
<a name="l00152"></a>00152                  &amp;<a class="code" href="l__pipe__util_8c.html#9142d5510348648db05b36ee12f6058e">Lpipe_debug_upper_cb_bound</a>);
<a name="l00153"></a>00153   L_read_parm_b (ppi, <span class="stringliteral">"print_pipelining_statistics"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#ab2140575cdf9b3526e6da5ea095a784">Lpipe_print_statistics</a>);
<a name="l00154"></a>00154   L_read_parm_b (ppi, <span class="stringliteral">"print_iteration_schedule"</span>,
<a name="l00155"></a>00155                  &amp;<a class="code" href="l__pipe__util_8c.html#f65026de9f77648de4df3b4f4ec74417">Lpipe_print_iteration_schedule</a>);
<a name="l00156"></a>00156   L_read_parm_b (ppi, <span class="stringliteral">"print_schedules_for_debug"</span>,
<a name="l00157"></a>00157                  &amp;<a class="code" href="l__pipe__util_8c.html#0b64713f1a54406156072dd81814ea25">Lpipe_print_schedules_for_debug</a>);
<a name="l00158"></a>00158   L_read_parm_b (ppi, <span class="stringliteral">"print_mve_summary"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#39d6ce980c9450094cb1c9372292b9ac">Lpipe_print_mve_summary</a>);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   L_read_parm_b (ppi, <span class="stringliteral">"?compute_loop_reg_pressure"</span>,
<a name="l00161"></a>00161                  &amp;<a class="code" href="l__pipe__util_8c.html#05b449c92ca8c59d61db6054cd56e7ee">Lpipe_compute_loop_reg_pressure</a>);
<a name="l00162"></a>00162   L_read_parm_b (ppi, <span class="stringliteral">"?add_spill_attributes"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#e2d1368da174d6c3c8b7ec7d1cbbf44e">Lpipe_add_spill_attributes</a>);
<a name="l00163"></a>00163 
<a name="l00164"></a>00164   L_read_parm_b (ppi, <span class="stringliteral">"?pipe_dump_dot"</span>, &amp;<a class="code" href="l__pipe__util_8c.html#2b86b75abb1973402ba2363621a03bb3">Lpipe_dump_dot</a>);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   <span class="comment">/* Verify correctness of certain parameters. */</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="keywordflow">if</span> (<a class="code" href="l__pipe__util_8c.html#a50c2551f678955eabc6e79793268ffa">Lpipe_budget_ratio</a> &lt; 1.0)
<a name="l00169"></a>00169     {
<a name="l00170"></a>00170       L_punt (<span class="stringliteral">"L_read_parm_lpipe: it is impossible to schedule the loop "</span>
<a name="l00171"></a>00171               <span class="stringliteral">"with a budget_ratio less than 1.0\n"</span>);
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="comment">/* Lpipe_schema options:</span>
<a name="l00175"></a>00175 <span class="comment">     REM_LOOP 0              remainder_loop</span>
<a name="l00176"></a>00176 <span class="comment">     MULTI_EPI 1             multiple_epilogues</span>
<a name="l00177"></a>00177 <span class="comment">     MULTI_EPI_ROT_REG 2     multiple_epilogues_rotating_registers</span>
<a name="l00178"></a>00178 <span class="comment">     KERNEL_ONLY 3           kernel_only</span>
<a name="l00179"></a>00179 <span class="comment">     note that KERNEL_ONLY is a form of modulo scheduling where the</span>
<a name="l00180"></a>00180 <span class="comment">     prologue and epilogue are executed using predication, and</span>
<a name="l00181"></a>00181 <span class="comment">     does NOT just generate a kernel for debugging purposes! MCM</span>
<a name="l00182"></a>00182 <span class="comment">   */</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="comment">/* Initialize the integer equivalent of the code generation schema name */</span>
<a name="l00185"></a>00185   <span class="keywordflow">if</span> (!strcmp (<a class="code" href="l__pipe__util_8c.html#659205866ba47e73cc85c2376ecd1985">Lpipe_schema_name</a>, <span class="stringliteral">"remainder_loop"</span>))
<a name="l00186"></a>00186     {
<a name="l00187"></a>00187       <a class="code" href="l__pipe__util_8c.html#9929661b757af9845e6325f4752a7d87">Lpipe_schema</a> = <a class="code" href="l__pipe__util_8h.html#3225a520483e53a39cab55104dcd0e5a">REM_LOOP</a>;
<a name="l00188"></a>00188     }
<a name="l00189"></a>00189   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp (Lpipe_schema_name, <span class="stringliteral">"multiple_epilogues"</span>))
<a name="l00190"></a>00190     {
<a name="l00191"></a>00191       <a class="code" href="l__pipe__util_8c.html#9929661b757af9845e6325f4752a7d87">Lpipe_schema</a> = <a class="code" href="l__pipe__util_8h.html#50a9671342717fc27f66fbb4178f4827">MULTI_EPI</a>;
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193   <span class="keywordflow">else</span>
<a name="l00194"></a>00194     <span class="keywordflow">if</span> (!strcmp (Lpipe_schema_name, <span class="stringliteral">"multiple_epilogues_rotating_registers"</span>))
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196       <a class="code" href="l__pipe__util_8c.html#9929661b757af9845e6325f4752a7d87">Lpipe_schema</a> = <a class="code" href="l__pipe__util_8h.html#82cbec0da6d1aaa4fc4326173c92f608">MULTI_EPI_ROT_REG</a>;
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp (Lpipe_schema_name, <span class="stringliteral">"kernel_only"</span>))
<a name="l00199"></a>00199     {
<a name="l00200"></a>00200       <a class="code" href="l__pipe__util_8c.html#9929661b757af9845e6325f4752a7d87">Lpipe_schema</a> = <a class="code" href="l__pipe__util_8h.html#7c9c77d70fb6ca9475c561bedd2b6b8a">KERNEL_ONLY</a>;
<a name="l00201"></a>00201     }
<a name="l00202"></a>00202   <span class="keywordflow">else</span>
<a name="l00203"></a>00203     {
<a name="l00204"></a>00204       L_punt (<span class="stringliteral">"L_read_parm_lpipe: %s is an invalid code schema"</span>,
<a name="l00205"></a>00205               Lpipe_schema_name);
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208   <span class="keywordflow">return</span>;
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="comment">/*************************************************************************</span>
<a name="l00212"></a>00212 <span class="comment">                Queue Function Definitions</span>
<a name="l00213"></a>00213 <span class="comment">*************************************************************************/</span>
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="comment">/* create and initialize a queue */</span>
<a name="l00216"></a>00216 <a class="code" href="structQueue.html">Queue</a> *
<a name="l00217"></a><a class="code" href="l__pipe__util_8h.html#cdc1d20712bda5896582534b68c4acbf">00217</a> <a class="code" href="l__pipe__util_8c.html#cdc1d20712bda5896582534b68c4acbf">Q_create_queue</a> ()
<a name="l00218"></a>00218 {
<a name="l00219"></a>00219   <a class="code" href="structQueue.html">Queue</a> *queue;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   queue = (<a class="code" href="structQueue.html">Queue</a> *) L_alloc (<a class="code" href="l__pipe__util_8c.html#4a9d1f680824f7426e01b910d4cc2b03">Queue_pool</a>);
<a name="l00222"></a>00222   queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> = queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a> = 0;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="keywordflow">return</span> (queue);
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="comment">/* free all queue nodes and reinitialize queue */</span>
<a name="l00228"></a>00228 <span class="keywordtype">void</span>
<a name="l00229"></a><a class="code" href="l__pipe__util_8h.html#8a2a321420befe6a29c8ad803115cdc0">00229</a> <a class="code" href="l__pipe__util_8c.html#df1c12ac44e95b30e76ae8af8d4b7e4c">Q_reinit_queue</a> (<a class="code" href="structQueue.html">Queue</a> * queue)
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231   <a class="code" href="structQnode.html">Qnode</a> *qnode;
<a name="l00232"></a>00232   <a class="code" href="structQnode.html">Qnode</a> *next_qnode;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234   <span class="keywordflow">for</span> (qnode = queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a>; qnode != NULL; qnode = next_qnode)
<a name="l00235"></a>00235     {
<a name="l00236"></a>00236       next_qnode = qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a>;
<a name="l00237"></a>00237       L_free (<a class="code" href="l__pipe__util_8c.html#b2b35dba38efd9d6e53512e38d014729">Qnode_pool</a>, qnode);
<a name="l00238"></a>00238     }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240   queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> = queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a> = 0;
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="comment">/* free all queue nodes and delete queue */</span>
<a name="l00244"></a>00244 <span class="keywordtype">void</span>
<a name="l00245"></a><a class="code" href="l__pipe__util_8h.html#11ae875063d836b46f834dde6210bc16">00245</a> <a class="code" href="l__pipe__util_8c.html#942148e69d79ed6f032311fc5f673ec1">Q_delete_queue</a> (<a class="code" href="structQueue.html">Queue</a> * queue)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247   <a class="code" href="structQnode.html">Qnode</a> *qnode;
<a name="l00248"></a>00248   <a class="code" href="structQnode.html">Qnode</a> *next_qnode;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   <span class="keywordflow">for</span> (qnode = queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a>; qnode != NULL; qnode = next_qnode)
<a name="l00251"></a>00251     {
<a name="l00252"></a>00252       next_qnode = qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a>;
<a name="l00253"></a>00253       L_free (<a class="code" href="l__pipe__util_8c.html#b2b35dba38efd9d6e53512e38d014729">Qnode_pool</a>, qnode);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255   L_free (<a class="code" href="l__pipe__util_8c.html#4a9d1f680824f7426e01b910d4cc2b03">Queue_pool</a>, queue);
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="comment">/* Enqueue opers in order of increasing priority; i.e., oper with lowest</span>
<a name="l00259"></a>00259 <span class="comment">   numerical priority value is at the head of the queue */</span>
<a name="l00260"></a>00260 <span class="keywordtype">void</span>
<a name="l00261"></a><a class="code" href="l__pipe__util_8h.html#5ae752c73b9349546549ee048228a045">00261</a> <a class="code" href="l__pipe__util_8c.html#5d0d8ff30543d84c18044af612092e86">Q_priority_enqueue_increasing</a> (<a class="code" href="structQueue.html">Queue</a> * queue, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> * oper, <span class="keywordtype">int</span> priority)
<a name="l00262"></a>00262 {
<a name="l00263"></a>00263   <a class="code" href="structQnode.html">Qnode</a> *qnode;
<a name="l00264"></a>00264   <a class="code" href="structQnode.html">Qnode</a> *qtmp;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   <span class="comment">/* create qnode for oper */</span>
<a name="l00267"></a>00267   qnode = (<a class="code" href="structQnode.html">Qnode</a> *) L_alloc (<a class="code" href="l__pipe__util_8c.html#b2b35dba38efd9d6e53512e38d014729">Qnode_pool</a>);
<a name="l00268"></a>00268   qnode-&gt;<a class="code" href="structQnode.html#3aec68cc8a3e9cc21bfa9cdcc705b3f9">oper</a> = oper;
<a name="l00269"></a>00269   qnode-&gt;<a class="code" href="structQnode.html#b3dc52a9270a3beba7d4fcc3b9c0fc10">priority</a> = priority;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271   <span class="keywordflow">if</span> (<a class="code" href="l__pipe__util_8c.html#ad83dd0fea79c90886829873235d97be">Lpipe_debug</a> &gt;= 2)
<a name="l00272"></a>00272     printf (<span class="stringliteral">"enqueue increasing: op %d with priority %d\n"</span>,
<a name="l00273"></a>00273             oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>-&gt;id, priority);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275   <span class="comment">/* empty queue */</span>
<a name="l00276"></a>00276   <span class="keywordflow">if</span> (queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> == NULL)
<a name="l00277"></a>00277     {
<a name="l00278"></a>00278       queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> = queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a> = qnode;
<a name="l00279"></a>00279       qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = qnode-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = 0;
<a name="l00280"></a>00280       <span class="keywordflow">return</span>;
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <span class="comment">/* not empty queue */</span>
<a name="l00284"></a>00284   <span class="keywordflow">for</span> (qtmp = queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a>; qtmp != NULL; qtmp = qtmp-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a>)
<a name="l00285"></a>00285     {
<a name="l00286"></a>00286       <span class="comment">/* Find oper's place in queue.  If two opers have the same priority,</span>
<a name="l00287"></a>00287 <span class="comment">         they are dequeued in the same order enqueued. */</span>
<a name="l00288"></a>00288       <span class="keywordflow">if</span> (qnode-&gt;<a class="code" href="structQnode.html#b3dc52a9270a3beba7d4fcc3b9c0fc10">priority</a> &lt; qtmp-&gt;<a class="code" href="structQnode.html#b3dc52a9270a3beba7d4fcc3b9c0fc10">priority</a>)
<a name="l00289"></a>00289         {
<a name="l00290"></a>00290           qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = qtmp;
<a name="l00291"></a>00291           qnode-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = qtmp-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a>;
<a name="l00292"></a>00292           <span class="keywordflow">if</span> (qtmp-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> != NULL)
<a name="l00293"></a>00293             {
<a name="l00294"></a>00294               qtmp-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a>-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = qnode;
<a name="l00295"></a>00295             }
<a name="l00296"></a>00296           <span class="keywordflow">else</span>
<a name="l00297"></a>00297             {
<a name="l00298"></a>00298               queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> = qnode;
<a name="l00299"></a>00299             }
<a name="l00300"></a>00300           qtmp-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = qnode;
<a name="l00301"></a>00301           <span class="keywordflow">break</span>;
<a name="l00302"></a>00302         }
<a name="l00303"></a>00303       <span class="comment">/* oper is last in queue */</span>
<a name="l00304"></a>00304       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (qtmp == queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a>)
<a name="l00305"></a>00305         {
<a name="l00306"></a>00306           qnode-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = qtmp;
<a name="l00307"></a>00307           qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = 0;
<a name="l00308"></a>00308           qtmp-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = qnode;
<a name="l00309"></a>00309           queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a> = qnode;
<a name="l00310"></a>00310           <span class="keywordflow">break</span>;
<a name="l00311"></a>00311         }
<a name="l00312"></a>00312     }
<a name="l00313"></a>00313 }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="comment">/* Enqueue opers in order of decreasing priority; i.e., oper with highest</span>
<a name="l00316"></a>00316 <span class="comment">   numerical priority value is at the head of the queue */</span>
<a name="l00317"></a>00317 <span class="keywordtype">void</span>
<a name="l00318"></a><a class="code" href="l__pipe__util_8h.html#e3aff464ee7717b9aa8908499dcd3f5f">00318</a> <a class="code" href="l__pipe__util_8c.html#8fcbbb02452d1ca7f1fb27f24bf23fc9">Q_priority_enqueue_decreasing</a> (<a class="code" href="structQueue.html">Queue</a> * queue, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> * oper, <span class="keywordtype">int</span> priority)
<a name="l00319"></a>00319 {
<a name="l00320"></a>00320   <a class="code" href="structQnode.html">Qnode</a> *qnode;
<a name="l00321"></a>00321   <a class="code" href="structQnode.html">Qnode</a> *qtmp;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   <span class="comment">/* create qnode for oper */</span>
<a name="l00324"></a>00324   qnode = (<a class="code" href="structQnode.html">Qnode</a> *) L_alloc (<a class="code" href="l__pipe__util_8c.html#b2b35dba38efd9d6e53512e38d014729">Qnode_pool</a>);
<a name="l00325"></a>00325   qnode-&gt;<a class="code" href="structQnode.html#3aec68cc8a3e9cc21bfa9cdcc705b3f9">oper</a> = oper;
<a name="l00326"></a>00326   qnode-&gt;<a class="code" href="structQnode.html#b3dc52a9270a3beba7d4fcc3b9c0fc10">priority</a> = priority;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="keywordflow">if</span> (<a class="code" href="l__pipe__util_8c.html#ad83dd0fea79c90886829873235d97be">Lpipe_debug</a> &gt;= 2)
<a name="l00329"></a>00329     printf (<span class="stringliteral">"enqueue decreasing: op %d with priority %d\n"</span>,
<a name="l00330"></a>00330             oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>-&gt;id, priority);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="comment">/* empty queue */</span>
<a name="l00333"></a>00333   <span class="keywordflow">if</span> (queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> == NULL)
<a name="l00334"></a>00334     {
<a name="l00335"></a>00335       queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> = queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a> = qnode;
<a name="l00336"></a>00336       qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = qnode-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = 0;
<a name="l00337"></a>00337       <span class="keywordflow">return</span>;
<a name="l00338"></a>00338     }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   <span class="comment">/* not empty queue */</span>
<a name="l00341"></a>00341   <span class="keywordflow">for</span> (qtmp = queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a>; qtmp != NULL; qtmp = qtmp-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a>)
<a name="l00342"></a>00342     {
<a name="l00343"></a>00343       <span class="comment">/* Find oper's place in queue.  If two opers have the same priority,</span>
<a name="l00344"></a>00344 <span class="comment">         they are dequeued in the same order enqueued. */</span>
<a name="l00345"></a>00345       <span class="keywordflow">if</span> (qnode-&gt;<a class="code" href="structQnode.html#b3dc52a9270a3beba7d4fcc3b9c0fc10">priority</a> &gt; qtmp-&gt;<a class="code" href="structQnode.html#b3dc52a9270a3beba7d4fcc3b9c0fc10">priority</a>)
<a name="l00346"></a>00346         {
<a name="l00347"></a>00347           qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = qtmp;
<a name="l00348"></a>00348           qnode-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = qtmp-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a>;
<a name="l00349"></a>00349           <span class="keywordflow">if</span> (qtmp-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> != NULL)
<a name="l00350"></a>00350             {
<a name="l00351"></a>00351               qtmp-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a>-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = qnode;
<a name="l00352"></a>00352             }
<a name="l00353"></a>00353           <span class="keywordflow">else</span>
<a name="l00354"></a>00354             {
<a name="l00355"></a>00355               queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> = qnode;
<a name="l00356"></a>00356             }
<a name="l00357"></a>00357           qtmp-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = qnode;
<a name="l00358"></a>00358           <span class="keywordflow">break</span>;
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360       <span class="comment">/* oper is last in queue */</span>
<a name="l00361"></a>00361       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (qtmp == queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a>)
<a name="l00362"></a>00362         {
<a name="l00363"></a>00363           qnode-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = qtmp;
<a name="l00364"></a>00364           qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = 0;
<a name="l00365"></a>00365           qtmp-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> = qnode;
<a name="l00366"></a>00366           queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a> = qnode;
<a name="l00367"></a>00367           <span class="keywordflow">break</span>;
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370 }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="comment">/* remove and return oper at the head of the queue */</span>
<a name="l00373"></a>00373 <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *
<a name="l00374"></a><a class="code" href="l__pipe__util_8h.html#7b9451e5338281ce08f9f3900b0da2aa">00374</a> <a class="code" href="l__pipe__util_8c.html#133e3cf36bdcb5c8bd8a22cf3d73dc36">Q_dequeue</a> (<a class="code" href="structQueue.html">Queue</a> * queue)
<a name="l00375"></a>00375 {
<a name="l00376"></a>00376   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *oper;
<a name="l00377"></a>00377   <a class="code" href="structQnode.html">Qnode</a> *qnode;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379   <span class="keywordflow">if</span> (queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> == NULL)
<a name="l00380"></a>00380     <span class="keywordflow">return</span> 0;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382   qnode = queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a>;
<a name="l00383"></a>00383   oper = qnode-&gt;<a class="code" href="structQnode.html#3aec68cc8a3e9cc21bfa9cdcc705b3f9">oper</a>;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="comment">/* last oper in queue */</span>
<a name="l00386"></a>00386   <span class="keywordflow">if</span> (qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a> == NULL)
<a name="l00387"></a>00387     {
<a name="l00388"></a>00388       queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> = queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a> = 0;
<a name="l00389"></a>00389     }
<a name="l00390"></a>00390   <span class="comment">/* not last oper in queue */</span>
<a name="l00391"></a>00391   <span class="keywordflow">else</span>
<a name="l00392"></a>00392     {
<a name="l00393"></a>00393       qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a>-&gt;<a class="code" href="structQnode.html#ef9b69f39290fed76fa1d90abf33abf3">prev_qnode</a> = 0;
<a name="l00394"></a>00394       queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> = qnode-&gt;<a class="code" href="structQnode.html#baf1d277b57755bb0116b37e5edb5708">next_qnode</a>;
<a name="l00395"></a>00395     }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397   <span class="keywordflow">if</span> (<a class="code" href="l__pipe__util_8c.html#ad83dd0fea79c90886829873235d97be">Lpipe_debug</a> &gt;= 2)
<a name="l00398"></a>00398     printf (<span class="stringliteral">"dequeue: op %d with priority %d\n"</span>,
<a name="l00399"></a>00399             oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>-&gt;id, qnode-&gt;<a class="code" href="structQnode.html#b3dc52a9270a3beba7d4fcc3b9c0fc10">priority</a>);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   L_free (<a class="code" href="l__pipe__util_8c.html#b2b35dba38efd9d6e53512e38d014729">Qnode_pool</a>, qnode);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="keywordflow">return</span> (oper);
<a name="l00404"></a>00404 }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="comment">/* return oper at tail of queue without removing it */</span>
<a name="l00407"></a>00407 <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *
<a name="l00408"></a><a class="code" href="l__pipe__util_8h.html#1246c0756b8a3deb050a6bd75d6e5fa1">00408</a> <a class="code" href="l__pipe__util_8c.html#97fa4ed0e8f32c08ef93c041c69c542d">Q_peek_tail</a> (<a class="code" href="structQueue.html">Queue</a> * queue)
<a name="l00409"></a>00409 {
<a name="l00410"></a>00410   <span class="keywordflow">if</span> (queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a> != 0)
<a name="l00411"></a>00411     <span class="keywordflow">return</span> (queue-&gt;<a class="code" href="structQueue.html#fee6a6594dac629a1b7cb7d1b66c1242">tail</a>-&gt;<a class="code" href="structQnode.html#3aec68cc8a3e9cc21bfa9cdcc705b3f9">oper</a>);
<a name="l00412"></a>00412   <span class="keywordflow">else</span>
<a name="l00413"></a>00413     <span class="keywordflow">return</span> 0;
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">/* return oper at head of queue without removing it */</span>
<a name="l00417"></a>00417 <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *
<a name="l00418"></a><a class="code" href="l__pipe__util_8h.html#17f2ed633a7771cbc82b5df1aea6c12d">00418</a> <a class="code" href="l__pipe__util_8c.html#c31c6a79d7e89f946aa510fb48beeb21">Q_peek_head</a> (<a class="code" href="structQueue.html">Queue</a> * queue)
<a name="l00419"></a>00419 {
<a name="l00420"></a>00420   <span class="keywordflow">if</span> (queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a> != 0)
<a name="l00421"></a>00421     <span class="keywordflow">return</span> (queue-&gt;<a class="code" href="structQueue.html#ce2d277946f665c6b87a545102632cdf">head</a>-&gt;<a class="code" href="structQnode.html#3aec68cc8a3e9cc21bfa9cdcc705b3f9">oper</a>);
<a name="l00422"></a>00422   <span class="keywordflow">else</span>
<a name="l00423"></a>00423     <span class="keywordflow">return</span> 0;
<a name="l00424"></a>00424 }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">/*************************************************************************</span>
<a name="l00427"></a>00427 <span class="comment">                Utility Function Definitions</span>
<a name="l00428"></a>00428 <span class="comment">*************************************************************************/</span>
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="comment">/* Overhauled by MCM for ITI. */</span>
<a name="l00431"></a>00431 <span class="keywordtype">int</span>
<a name="l00432"></a><a class="code" href="l__pipe__util_8h.html#7b60097f302ea9ca9d9c2bda114cd370">00432</a> <a class="code" href="l__pipe__util_8c.html#af2a384e21644ca71a0c7f4a3a524d8d">Lpipe_reordered_anti_dependent_ops</a> (<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> * oper, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> * next_oper)
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html">SM_Dep</a> *dep;
<a name="l00435"></a>00435   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html">SM_Reg_Action</a> *dest_operand;
<a name="l00436"></a>00436   <span class="keywordtype">int</span> zero_cycle_dependent = 0;
<a name="l00437"></a>00437   <span class="keywordtype">int</span> anti_dependent = 0;
<a name="l00438"></a>00438   <span class="keywordtype">int</span> i, dest_number;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="comment">/* If there is a zero-cycle dependence between these two ops, </span>
<a name="l00441"></a>00441 <span class="comment">     return 0, reporting that these two ops are not reordered</span>
<a name="l00442"></a>00442 <span class="comment">     anti-dependent ops.  Note that SM creates dependences for anti-</span>
<a name="l00443"></a>00443 <span class="comment">     and output dependent instructions, but sets the ignore flag</span>
<a name="l00444"></a>00444 <span class="comment">     because MVE is assumed which will correct for this situation. */</span>
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <span class="keywordflow">for</span> (dest_number = 0; dest_number &lt; L_max_dest_operand; dest_number++)
<a name="l00447"></a>00447     {
<a name="l00448"></a>00448       dest_operand = oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#dd1e1bbe73565b3d3f0557ba3ba22c27">dest</a>[dest_number];
<a name="l00449"></a>00449 
<a name="l00450"></a>00450       if (dest_operand == NULL)
<a name="l00451"></a>00451         <span class="keywordflow">continue</span>;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453       <span class="keywordflow">for</span> (dep = dest_operand-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#3171073306749483352a4c892cfc6221">first_dep_out</a>; dep != NULL;
<a name="l00454"></a>00454            dep = dep-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#b504e52138aeabdcedf0a11fffa105a4">next_dep_out</a>)
<a name="l00455"></a>00455         {
<a name="l00456"></a>00456           if (dep-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#27d6dcd9ece66927e168825df329e1c6">to_action</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#870ffbe025aeb52318e352bf64d9d155">sm_op</a> == next_oper &amp;&amp;
<a name="l00457"></a>00457               dep-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#e239c4ea463b4cb1917c0b2aab2f5668">min_delay</a> == 0 &amp;&amp; dep-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#50dec9504610cd1b38099707f7102e50">omega</a> == 0 &amp;&amp; !dep-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#c86fd98a10649c5bc10931ef03c09bdf">ignore</a>)
<a name="l00458"></a>00458             {
<a name="l00459"></a>00459               zero_cycle_dependent = 1;
<a name="l00460"></a>00460               <span class="keywordflow">break</span>;
<a name="l00461"></a>00461             }
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464       <span class="keywordflow">if</span> (zero_cycle_dependent == 1)
<a name="l00465"></a>00465         <span class="keywordflow">break</span>;
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="keywordflow">if</span> (zero_cycle_dependent)
<a name="l00469"></a>00469     <span class="keywordflow">return</span> 0;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   anti_dependent = 0;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   <span class="comment">/* Check for anti-depedent ops.  This function assumes that op1 and</span>
<a name="l00474"></a>00474 <span class="comment">     op2 have been reversed in order.  Based on that assumption, look</span>
<a name="l00475"></a>00475 <span class="comment">     for a flow dependence between the instructions when using simple</span>
<a name="l00476"></a>00476 <span class="comment">     dest and src operand names.  One could also look for an anti-dep</span>
<a name="l00477"></a>00477 <span class="comment">     SM dependence arc between the instructions with the ignore flag</span>
<a name="l00478"></a>00478 <span class="comment">     (MVE assumed) set.  At the time of this writing, we weren't sure</span>
<a name="l00479"></a>00479 <span class="comment">     if the MVE ignored arcs would be actually deleted or just ignored</span>
<a name="l00480"></a>00480 <span class="comment">     via the flag, so the original register comparison is used. */</span>
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   <span class="keywordflow">for</span> (i = 0; i &lt; L_max_dest_operand; i++)
<a name="l00483"></a>00483     {
<a name="l00484"></a>00484       <span class="keywordflow">if</span> (oper-&gt;lcode_op-&gt;dest[i] != NULL &amp;&amp;
<a name="l00485"></a>00485           L_is_src_operand (oper-&gt;lcode_op-&gt;dest[i], next_oper-&gt;lcode_op))
<a name="l00486"></a>00486         {
<a name="l00487"></a>00487           anti_dependent = 1;
<a name="l00488"></a>00488           <span class="keywordflow">break</span>;
<a name="l00489"></a>00489         }
<a name="l00490"></a>00490     }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="keywordflow">if</span> (anti_dependent)
<a name="l00493"></a>00493     <span class="keywordflow">return</span> 1;
<a name="l00494"></a>00494   <span class="keywordflow">else</span>
<a name="l00495"></a>00495     <span class="keywordflow">return</span> 0;
<a name="l00496"></a>00496 }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="comment">/*************************************************************************</span>
<a name="l00500"></a>00500 <span class="comment">                Dependence Ignoring Utilities</span>
<a name="l00501"></a>00501 <span class="comment">*************************************************************************/</span>
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 <span class="comment">/* Self dependencies are need for rec_mii calculation but</span>
<a name="l00504"></a>00504 <span class="comment">   not for scheduling! */</span>
<a name="l00505"></a>00505 <span class="keywordtype">void</span>
<a name="l00506"></a><a class="code" href="l__pipe__util_8h.html#307da7f36b0c185cc93cccaabef4a233">00506</a> <a class="code" href="l__pipe__util_8c.html#fe0fa3d6120b61b121fc43231a6d890d">Lpipe_ignore_self_dependences</a> (<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html">SM_Cb</a> * sm_cb)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *sm_oper, *from_sm_oper;
<a name="l00509"></a>00509   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html">SM_Reg_Action</a> *action;
<a name="l00510"></a>00510   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html">SM_Dep</a> *dep_in;
<a name="l00511"></a>00511   <a class="code" href="struct__Softpipe__Op__Info.html">Softpipe_Op_Info</a> *softpipe_info, *from_softpipe_info;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="keywordflow">for</span> (sm_oper = sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#a89868f9a5bb0dabe28a9c74d44a6286">first_serial_op</a>; sm_oper != NULL;
<a name="l00514"></a>00514        sm_oper = sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#c7c35fc98ddf3d343118f16a6bfd0f99">next_serial_op</a>)
<a name="l00515"></a>00515     {
<a name="l00516"></a>00516       softpipe_info = <a class="code" href="l__softpipe__int_8h.html#50a06a5d593647c987ffc62034b61991">SOFTPIPE_OP_INFO</a> (sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518       <span class="keywordflow">for</span> (action = sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#57586b443ee0ac219ebbdec855fd410d">first_op_action</a>; action != NULL;
<a name="l00519"></a>00519            action = action-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#006ea32b06272e80d00b880e2858a926">next_op_action</a>)
<a name="l00520"></a>00520         {
<a name="l00521"></a>00521           <span class="keywordflow">for</span> (dep_in = action-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#60b920d4ec6481af314c5d8a35b08e41">first_dep_in</a>; dep_in != NULL;
<a name="l00522"></a>00522                dep_in = dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#7db7e3db6b52d38f70d0a5e6d0b28b31">next_dep_in</a>)
<a name="l00523"></a>00523             {
<a name="l00524"></a>00524               from_sm_oper = dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#7986bc3d4adf6769d8bbfc26d6ad55b9">from_action</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#870ffbe025aeb52318e352bf64d9d155">sm_op</a>;
<a name="l00525"></a>00525               from_softpipe_info = <a class="code" href="l__softpipe__int_8h.html#50a06a5d593647c987ffc62034b61991">SOFTPIPE_OP_INFO</a> (from_sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527               <span class="keywordflow">if</span> (sm_oper == from_sm_oper &amp;&amp; !dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#c86fd98a10649c5bc10931ef03c09bdf">ignore</a>)
<a name="l00528"></a>00528                 <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#788482acf72fd688418e5d4560967a4a">SM_ignore_dep</a> (dep_in, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#9ad2806dd5b02ac768ecbe8153eb871a">SM_MVE_IGNORE</a>);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530               <span class="comment">/* If the originating node is a start or stop node, then</span>
<a name="l00531"></a>00531 <span class="comment">                 ignore any created dependences to start or stop</span>
<a name="l00532"></a>00532 <span class="comment">                 nodes. */</span>
<a name="l00533"></a>00533               <span class="keywordflow">else</span>
<a name="l00534"></a>00534                 <span class="keywordflow">if</span> ((L_START_NODE (sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>)
<a name="l00535"></a>00535                      &amp;&amp; L_STOP_NODE (from_sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>)) ||
<a name="l00536"></a>00536                     (L_STOP_NODE (sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>)
<a name="l00537"></a>00537                      &amp;&amp; L_START_NODE (from_sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>)))
<a name="l00538"></a>00538                 <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#788482acf72fd688418e5d4560967a4a">SM_ignore_dep</a> (dep_in, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#9ad2806dd5b02ac768ecbe8153eb871a">SM_MVE_IGNORE</a>);
<a name="l00539"></a>00539             }
<a name="l00540"></a>00540         }
<a name="l00541"></a>00541     }
<a name="l00542"></a>00542   <span class="keywordflow">return</span>;
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 <span class="comment">/* Find loop back branch.  Single basic block cbs that end with</span>
<a name="l00547"></a>00547 <span class="comment">   an unconditional jump to the fall through path </span>
<a name="l00548"></a>00548 <span class="comment">   will be broken into two blocks during loop </span>
<a name="l00549"></a>00549 <span class="comment">   prep: one for the loop, one for the jump after the loop back </span>
<a name="l00550"></a>00550 <span class="comment">   branch.  Assume loop does not end with an unconditional jump back </span>
<a name="l00551"></a>00551 <span class="comment">   to header or other operations after the loop back branch. */</span>
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 L_Oper *
<a name="l00554"></a><a class="code" href="l__pipe__util_8h.html#205159e237371c2666b10787e5ecdb95">00554</a> <a class="code" href="l__pipe__util_8c.html#a00a3d794df406f15d3d85b20f483941">Lpipe_find_loop_back_br</a> (L_Func * fn, L_Cb * <a class="code" href="l__softpipe_8c.html#91e84fa9645e4d3beb7b8b6c150da74b">header_cb</a>)
<a name="l00555"></a>00555 {
<a name="l00556"></a>00556   L_Oper *oper;
<a name="l00557"></a>00557   L_Oper *loop_back_br = NULL;
<a name="l00558"></a>00558   <span class="keywordtype">int</span> found = 0;                <span class="comment">/* flag to indicate that loop back</span>
<a name="l00559"></a>00559 <span class="comment">                                   branch has been found */</span>
<a name="l00560"></a>00560 
<a name="l00561"></a>00561   <span class="keywordflow">for</span> (oper = header_cb-&gt;last_op; oper != NULL; oper = oper-&gt;prev_op)
<a name="l00562"></a>00562     {
<a name="l00563"></a>00563       <span class="comment">/* loop back branch must be conditional branch */</span>
<a name="l00564"></a>00564       <span class="keywordflow">if</span> (L_cond_branch (oper) &amp;&amp; (L_find_branch_dest (oper) == header_cb))
<a name="l00565"></a>00565         {
<a name="l00566"></a>00566           <span class="keywordflow">if</span> (!found)
<a name="l00567"></a>00567             {
<a name="l00568"></a>00568               found = 1;
<a name="l00569"></a>00569               loop_back_br = oper;
<a name="l00570"></a>00570             }
<a name="l00571"></a>00571           <span class="keywordflow">else</span>
<a name="l00572"></a>00572             {
<a name="l00573"></a>00573               L_punt (<span class="stringliteral">"Lpipe_find_loop_back_br: more than one branch back to "</span>
<a name="l00574"></a>00574                       <span class="stringliteral">"header cb: %d"</span>, header_cb-&gt;id);
<a name="l00575"></a>00575             }
<a name="l00576"></a>00576         }
<a name="l00577"></a>00577       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_uncond_branch (oper) &amp;&amp;
<a name="l00578"></a>00578                (L_find_branch_dest (oper) == header_cb))
<a name="l00579"></a>00579         {
<a name="l00580"></a>00580           L_punt (<span class="stringliteral">"Lpipe_find_loop_back_br: Loop ended with"</span>
<a name="l00581"></a>00581                   <span class="stringliteral">"unconditional jump to header cb: %d"</span>, header_cb-&gt;id);
<a name="l00582"></a>00582         }
<a name="l00583"></a>00583       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_general_branch_opcode (oper))
<a name="l00584"></a>00584         {
<a name="l00585"></a>00585           <span class="keywordflow">if</span> (found)
<a name="l00586"></a>00586             {
<a name="l00587"></a>00587               L_punt (<span class="stringliteral">"Lpipe_find_loop_back_br: "</span>
<a name="l00588"></a>00588                       <span class="stringliteral">"loop has an early exit. cb: %d"</span>, header_cb-&gt;id);
<a name="l00589"></a>00589             }
<a name="l00590"></a>00590         }
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="keywordflow">if</span> (found)
<a name="l00594"></a>00594     <span class="keywordflow">return</span> (loop_back_br);
<a name="l00595"></a>00595   <span class="keywordflow">else</span>
<a name="l00596"></a>00596     L_punt (<span class="stringliteral">"Lpipe_find_loop_back_br: "</span>
<a name="l00597"></a>00597             <span class="stringliteral">"could not find loop back branch. cb: %d"</span>, header_cb-&gt;id);
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="keywordflow">return</span> (0);
<a name="l00600"></a>00600 }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 <span class="comment">/* For remainder loop, remove all branches in kernel, except last one */</span>
<a name="l00604"></a>00604 <span class="keywordtype">void</span>
<a name="l00605"></a><a class="code" href="l__pipe__util_8h.html#b00f5d107ce583fe74323bce6d807120">00605</a> <a class="code" href="l__pipe__util_8c.html#c7e6b4cf559095203372239c9544b2a8">Lpipe_remove_branches</a> (L_Func * fn, <span class="keywordtype">int</span> unroll)
<a name="l00606"></a>00606 {
<a name="l00607"></a>00607   L_Oper *oper;
<a name="l00608"></a>00608   <a class="code" href="struct__Softpipe__Op__Info.html">Softpipe_Op_Info</a> *softpipe_info;
<a name="l00609"></a>00609   L_Oper *next_op;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="keywordflow">for</span> (oper = <a class="code" href="l__softpipe_8c.html#91e84fa9645e4d3beb7b8b6c150da74b">header_cb</a>-&gt;first_op; oper != NULL; oper = next_op)
<a name="l00612"></a>00612     {
<a name="l00613"></a>00613       next_op = oper-&gt;next_op;
<a name="l00614"></a>00614       softpipe_info = <a class="code" href="l__softpipe__int_8h.html#50a06a5d593647c987ffc62034b61991">SOFTPIPE_OP_INFO</a> (oper);
<a name="l00615"></a>00615       <span class="keywordflow">if</span> ((L_int_cond_branch_opcode (oper)) &amp;&amp;
<a name="l00616"></a>00616           (softpipe_info-&gt;<a class="code" href="struct__Softpipe__Op__Info.html#3fadf4a8a69a2dad970274041fed7e69">kernel_copy</a> != (unroll - 1)))
<a name="l00617"></a>00617         {
<a name="l00618"></a>00618           L_free (<a class="code" href="l__softpipe__info_8c.html#bec30e2c6dd19674777250eed6a17946">Softpipe_Op_Info_pool</a>, softpipe_info);
<a name="l00619"></a>00619           L_delete_oper (<a class="code" href="l__softpipe_8c.html#91e84fa9645e4d3beb7b8b6c150da74b">header_cb</a>, oper);
<a name="l00620"></a>00620         }
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="keywordtype">void</span>
<a name="l00626"></a><a class="code" href="l__pipe__util_8h.html#ec1fbdb678fe723bd9872d734ef7647f">00626</a> <a class="code" href="l__pipe__util_8c.html#d0e4be247037cc75bcca0eeebb56dc71">Lpipe_cb_set_iter</a> (<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html">SM_Cb</a> * sm_cb)
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *sm_op;
<a name="l00629"></a>00629   L_Oper *oper;
<a name="l00630"></a>00630   L_Attr *attr;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632   <span class="keywordflow">for</span> (sm_op = sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#a89868f9a5bb0dabe28a9c74d44a6286">first_serial_op</a>; sm_op != NULL;
<a name="l00633"></a>00633        sm_op = sm_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#c7c35fc98ddf3d343118f16a6bfd0f99">next_serial_op</a>)
<a name="l00634"></a>00634     {
<a name="l00635"></a>00635       oper = sm_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>;
<a name="l00636"></a>00636       <span class="comment">/* Set iteration attribute for copy 0 of kernel.  Copy numbers</span>
<a name="l00637"></a>00637 <span class="comment">         go from 0 to unroll-1.  Iteration numbers go from 1 to unroll. </span>
<a name="l00638"></a>00638 <span class="comment">         The iteration numbers for the first copy need to be set</span>
<a name="l00639"></a>00639 <span class="comment">         before the kernel is unrolled.  The numbers for the other</span>
<a name="l00640"></a>00640 <span class="comment">         copies (if any) will be set during unrolling. */</span>
<a name="l00641"></a>00641       <span class="keywordflow">if</span> (!(attr = L_find_attr (oper-&gt;attr, <span class="stringliteral">"iter"</span>)))
<a name="l00642"></a>00642         {
<a name="l00643"></a>00643           attr = L_new_attr (<span class="stringliteral">"iter"</span>, 1);
<a name="l00644"></a>00644           oper-&gt;attr = L_concat_attr (oper-&gt;attr, attr);
<a name="l00645"></a>00645         }
<a name="l00646"></a>00646       L_set_int_attr_field (attr, 0, 1);
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650 <span class="keywordtype">void</span>
<a name="l00651"></a><a class="code" href="l__pipe__util_8h.html#78c301317333e39c1f990dd753b7702a">00651</a> <a class="code" href="l__pipe__util_8c.html#0b7f0cae0da09da3e5d8b982be9873e0">Lpipe_cb_set_issue_time</a> (<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html">SM_Cb</a> * sm_cb)
<a name="l00652"></a>00652 {
<a name="l00653"></a>00653   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *sm_op;
<a name="l00654"></a>00654   L_Oper *oper;
<a name="l00655"></a>00655   L_Attr *attr;
<a name="l00656"></a>00656   <a class="code" href="struct__Softpipe__Op__Info.html">Softpipe_Op_Info</a> *softpipe_info;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <span class="keywordflow">for</span> (sm_op = sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#a89868f9a5bb0dabe28a9c74d44a6286">first_serial_op</a>; sm_op != NULL;
<a name="l00659"></a>00659        sm_op = sm_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#c7c35fc98ddf3d343118f16a6bfd0f99">next_serial_op</a>)
<a name="l00660"></a>00660     {
<a name="l00661"></a>00661       oper = sm_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663       softpipe_info = <a class="code" href="l__softpipe__int_8h.html#50a06a5d593647c987ffc62034b61991">SOFTPIPE_OP_INFO</a> (oper);
<a name="l00664"></a>00664 
<a name="l00665"></a>00665       <span class="keywordflow">if</span> (!(attr = L_find_attr (oper-&gt;attr, <span class="stringliteral">"issue_time"</span>)))
<a name="l00666"></a>00666         {
<a name="l00667"></a>00667           attr = L_new_attr (<span class="stringliteral">"issue_time"</span>, 1);
<a name="l00668"></a>00668           oper-&gt;attr = L_concat_attr (oper-&gt;attr, attr);
<a name="l00669"></a>00669         }
<a name="l00670"></a>00670       L_set_int_attr_field (attr, 0, softpipe_info-&gt;<a class="code" href="struct__Softpipe__Op__Info.html#f69da927376f1a1b3c0b3fc0ed76fb65">issue_time</a>);
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672 }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="comment">/* This function consumes the L_Operands! */</span>
<a name="l00675"></a>00675 L_Oper *
<a name="l00676"></a><a class="code" href="l__pipe__util_8h.html#9df034fd9bbb4661af51542996abeacc">00676</a> <a class="code" href="l__pipe__util_8c.html#af4d8d01138767db21c4b576f99cd96d">Lpipe_gen_uncond_pred_define</a> (L_Operand * pred0, L_Operand * pred1,
<a name="l00677"></a>00677                               L_Operand * dest, <span class="keywordtype">int</span> opc)
<a name="l00678"></a>00678 {
<a name="l00679"></a>00679   L_Oper *new_oper = L_create_new_op (Lop_CMP);
<a name="l00680"></a>00680   L_set_compare (new_oper, <a class="codeRef" doxygen="libmspec.tag:../../../../machine/Mspec/html/" href="../../../../machine/Mspec/html/m__spec_8h.html#8a083ae12702137e4e8eefe2e8204b54">M_native_int_register_ctype</a> (), Lcmp_COM_EQ);
<a name="l00681"></a>00681   new_oper-&gt;pred[0] = pred0;
<a name="l00682"></a>00682   new_oper-&gt;pred[1] = pred1;
<a name="l00683"></a>00683   new_oper-&gt;dest[0] = dest;
<a name="l00684"></a>00684   new_oper-&gt;src[0] = L_new_gen_int_operand (0);
<a name="l00685"></a>00685   new_oper-&gt;src[1] = L_new_gen_int_operand (0);
<a name="l00686"></a>00686 
<a name="l00687"></a>00687   <span class="keywordflow">if</span> (opc == Lop_PRED_CLEAR)
<a name="l00688"></a>00688     {
<a name="l00689"></a>00689       new_oper-&gt;dest[0]-&gt;ptype = L_PTYPE_UNCOND_F;
<a name="l00690"></a>00690     }
<a name="l00691"></a>00691   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc == Lop_PRED_SET)
<a name="l00692"></a>00692     {
<a name="l00693"></a>00693       new_oper-&gt;dest[0]-&gt;ptype = L_PTYPE_UNCOND_T;
<a name="l00694"></a>00694     }
<a name="l00695"></a>00695   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opc == Lop_PRED_COPY)
<a name="l00696"></a>00696     {
<a name="l00697"></a>00697       L_punt (<span class="stringliteral">"Lpipe_gen_uncond_pred_define: "</span>
<a name="l00698"></a>00698               <span class="stringliteral">"Lop_PRED_COPY not implemented.\n"</span>);
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700   <span class="keywordflow">else</span>
<a name="l00701"></a>00701     {
<a name="l00702"></a>00702       L_punt (<span class="stringliteral">"Lpipe_gen_uncond_pred_define: "</span> <span class="stringliteral">"opc not supported.\n"</span>);
<a name="l00703"></a>00703     }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="keywordflow">return</span> new_oper;
<a name="l00706"></a>00706 }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708 <span class="comment">/*</span>
<a name="l00709"></a>00709 <span class="comment"> * Transform pred_clear / pred_xx o{t|f} pairs into </span>
<a name="l00710"></a>00710 <span class="comment"> * unconditional predciate defines where possible.</span>
<a name="l00711"></a>00711 <span class="comment"> */</span>
<a name="l00712"></a>00712 <span class="keywordtype">void</span>
<a name="l00713"></a><a class="code" href="l__pipe__util_8h.html#d5047dd886071898fb70d91fb6f80e99">00713</a> <a class="code" href="l__pipe__util_8c.html#8e12dca1f06e9f8f224a39473ba1bb81">Lpipe_create_uncond_pred_defines</a> (L_Func * fn)
<a name="l00714"></a>00714 {
<a name="l00715"></a>00715   <span class="keywordtype">int</span> i;
<a name="l00716"></a>00716   L_Cb *cb;
<a name="l00717"></a>00717   L_Oper *oper, *new_oper;
<a name="l00718"></a>00718   L_Operand *dest;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   <span class="keywordflow">for</span> (cb = fn-&gt;first_cb; cb != NULL; cb = cb-&gt;next_cb)
<a name="l00721"></a>00721     {
<a name="l00722"></a>00722       <span class="keywordflow">if</span> (!L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_HYPERBLOCK))
<a name="l00723"></a>00723         <span class="keywordflow">continue</span>;
<a name="l00724"></a>00724       <span class="keywordflow">for</span> (oper = cb-&gt;first_op; oper != NULL; oper = oper-&gt;next_op)
<a name="l00725"></a>00725         {
<a name="l00726"></a>00726           new_oper = NULL;
<a name="l00727"></a>00727 
<a name="l00728"></a>00728           <span class="keywordflow">if</span> (!L_initializing_predicate_define_opcode (oper))
<a name="l00729"></a>00729             <span class="keywordflow">continue</span>;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731           <span class="keywordflow">for</span> (i = 0; i &lt; L_max_dest_operand; i++)
<a name="l00732"></a>00732             {
<a name="l00733"></a>00733               dest = oper-&gt;dest[i];
<a name="l00734"></a>00734               if (dest == NULL)
<a name="l00735"></a>00735                 <span class="keywordflow">continue</span>;
<a name="l00736"></a>00736               <span class="keywordflow">if</span> (dest-&gt;ptype != L_PTYPE_NULL)
<a name="l00737"></a>00737                 <span class="keywordflow">continue</span>;
<a name="l00738"></a>00738 
<a name="l00739"></a>00739               if (<a class="code" href="l__pipe__util_8c.html#ad83dd0fea79c90886829873235d97be">Lpipe_debug</a> &gt;= 1)
<a name="l00740"></a>00740                 fprintf (stdout, <span class="stringliteral">"Change r %d (op %d) to uncond predicate\n"</span>,
<a name="l00741"></a>00741                          dest-&gt;value.r, oper-&gt;id);
<a name="l00742"></a>00742 
<a name="l00743"></a>00743               new_oper =
<a name="l00744"></a>00744                 <a class="code" href="l__pipe__util_8c.html#af4d8d01138767db21c4b576f99cd96d">Lpipe_gen_uncond_pred_define</a> (L_copy_operand (oper-&gt;pred[0]),
<a name="l00745"></a>00745                                               L_copy_operand (oper-&gt;pred[1]),
<a name="l00746"></a>00746                                               L_copy_operand (dest),
<a name="l00747"></a>00747                                               oper-&gt;opc);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749               if (L_pred_clear (oper))
<a name="l00750"></a>00750                 {
<a name="l00751"></a>00751                   new_oper-&gt;dest[0]-&gt;ptype = L_PTYPE_UNCOND_F;
<a name="l00752"></a>00752                 }
<a name="l00753"></a>00753               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_pred_set (oper))
<a name="l00754"></a>00754                 {
<a name="l00755"></a>00755                   new_oper-&gt;dest[0]-&gt;ptype = L_PTYPE_UNCOND_T;
<a name="l00756"></a>00756                 }
<a name="l00757"></a>00757               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_pred_copy (oper))
<a name="l00758"></a>00758                 {
<a name="l00759"></a>00759                   L_punt (<span class="stringliteral">"Lpipe_create_uncond_pred_defines: "</span>
<a name="l00760"></a>00760                           <span class="stringliteral">"Lop_PRED_COPY not implemented: op %d\n"</span>, oper-&gt;id);
<a name="l00761"></a>00761                 }
<a name="l00762"></a>00762               <span class="keywordflow">else</span>
<a name="l00763"></a>00763                 {
<a name="l00764"></a>00764                   L_punt (<span class="stringliteral">"Lpipe_create_uncond_pred_defines: "</span>
<a name="l00765"></a>00765                           <span class="stringliteral">"opc not supported: op %d\n"</span>, oper-&gt;id);
<a name="l00766"></a>00766                 }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768               L_insert_oper_before (cb, oper, new_oper);
<a name="l00769"></a>00769             }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771           <span class="keywordflow">if</span> (new_oper != NULL)
<a name="l00772"></a>00772             {
<a name="l00773"></a>00773               oper = new_oper;
<a name="l00774"></a>00774               L_delete_oper (cb, oper-&gt;next_op);
<a name="l00775"></a>00775             }
<a name="l00776"></a>00776         }
<a name="l00777"></a>00777     }
<a name="l00778"></a>00778 }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780 
<a name="l00781"></a>00781 <span class="comment">/*************************************************************************</span>
<a name="l00782"></a>00782 <span class="comment">                Start/Stop Function Definitions</span>
<a name="l00783"></a>00783 <span class="comment">*************************************************************************/</span>
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 <span class="comment">/* add start and stop pseudo-nodes for the purpose of computing MinDist,</span>
<a name="l00786"></a>00786 <span class="comment">   priority, and earliest and latest issue time */</span>
<a name="l00787"></a>00787 <span class="keywordtype">void</span>
<a name="l00788"></a><a class="code" href="l__pipe__util_8h.html#a967bed10a5deec4a8f2949828656c72">00788</a> <a class="code" href="l__pipe__util_8c.html#4d45e5623b3ff132a813e2a9adf69150">Lpipe_create_start_stop_nodes</a> (<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html">SM_Cb</a> * sm_cb)
<a name="l00789"></a>00789 {
<a name="l00790"></a>00790   L_Oper *start_oper, *stop_oper;
<a name="l00791"></a>00791   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *sm_oper, *sm_start_oper, *sm_stop_oper;
<a name="l00792"></a>00792   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html">SM_Reg_Action</a> *action;
<a name="l00793"></a>00793   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html">SM_Dep</a> *dep_in;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   <span class="comment">/* create start node */</span>
<a name="l00796"></a>00796   start_oper = L_create_new_op (Lop_NO_OP);
<a name="l00797"></a>00797   sm_start_oper = <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8c.html#15c481b9c7cd129ace579e1e290a4385">SM_insert_oper_after</a> (sm_cb, start_oper, NULL);
<a name="l00798"></a>00798   <span class="comment">/* Make a sync source so that a sync dep can originate from this instr. */</span>
<a name="l00799"></a>00799   <span class="keywordflow">if</span> (!sm_start_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#fc6e609ae82e06f3089cb4206909e6ba">ext_dest</a>[<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>])
<a name="l00800"></a>00800     {
<a name="l00801"></a>00801       sm_start_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#fc6e609ae82e06f3089cb4206909e6ba">ext_dest</a>[<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>] =
<a name="l00802"></a>00802         <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#ccb8edcd77ee94f72aa7c5fa774f2a0f">SM_add_reg_action</a> (sm_start_oper, <a class="codeRef" doxygen="liblmdes.tag:../../../../machine/Lmdes/html/" href="../../../../machine/Lmdes/html/lmdes_8h.html#8d186a9d28efc70dbedced22702e23f8">MDES_SYNC_OUT</a>, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>,
<a name="l00803"></a>00803                            <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#5fdcbaa2b827ff4ae58c4631ebd137f6">SM_SYNC_ACTION_OPERAND</a>);
<a name="l00804"></a>00804     }
<a name="l00805"></a>00805   start_oper-&gt;ext = (<a class="code" href="struct__Softpipe__Op__Info.html">Softpipe_Op_Info</a> *) <a class="code" href="l__softpipe__info_8c.html#20e0bb7258cae1e6da705eff2689ea9c">Lpipe_create_op_info</a> ();
<a name="l00806"></a>00806   <a class="code" href="l__softpipe__info_8c.html#a1f243509717138e72fffec354e493a4">Lpipe_init_op_info</a> (sm_start_oper, -1, 0);
<a name="l00807"></a>00807   start_oper-&gt;flags = L_SET_BIT_FLAG (start_oper-&gt;flags, L_OPER_START_NODE);
<a name="l00808"></a>00808 
<a name="l00809"></a>00809   <span class="comment">/* create stop node */</span>
<a name="l00810"></a>00810   stop_oper = L_create_new_op (Lop_NO_OP);
<a name="l00811"></a>00811   sm_stop_oper = <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8c.html#15c481b9c7cd129ace579e1e290a4385">SM_insert_oper_after</a> (sm_cb, stop_oper,
<a name="l00812"></a>00812                                        sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#72a08b1707e79a4ac78ad8ee2e1a2574">last_serial_op</a>);
<a name="l00813"></a>00813   stop_oper-&gt;ext = (<a class="code" href="struct__Softpipe__Op__Info.html">Softpipe_Op_Info</a> *) <a class="code" href="l__softpipe__info_8c.html#20e0bb7258cae1e6da705eff2689ea9c">Lpipe_create_op_info</a> ();
<a name="l00814"></a>00814   <a class="code" href="l__softpipe__info_8c.html#a1f243509717138e72fffec354e493a4">Lpipe_init_op_info</a> (sm_stop_oper, -1, 0);
<a name="l00815"></a>00815   stop_oper-&gt;flags = L_SET_BIT_FLAG (stop_oper-&gt;flags, L_OPER_STOP_NODE);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817   <span class="comment">/* Extra dependences (sync) are automatically created between</span>
<a name="l00818"></a>00818 <span class="comment">     the start and stop opers.  They must be ignored. */</span>
<a name="l00819"></a>00819   <span class="keywordflow">for</span> (action = sm_start_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#57586b443ee0ac219ebbdec855fd410d">first_op_action</a>; action != NULL;
<a name="l00820"></a>00820        action = action-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#006ea32b06272e80d00b880e2858a926">next_op_action</a>)
<a name="l00821"></a>00821     {
<a name="l00822"></a>00822       <span class="keywordflow">for</span> (dep_in = action-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#60b920d4ec6481af314c5d8a35b08e41">first_dep_in</a>; dep_in != NULL;
<a name="l00823"></a>00823            dep_in = dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#7db7e3db6b52d38f70d0a5e6d0b28b31">next_dep_in</a>)
<a name="l00824"></a>00824         {
<a name="l00825"></a>00825           <span class="keywordflow">if</span> (dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#7986bc3d4adf6769d8bbfc26d6ad55b9">from_action</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#870ffbe025aeb52318e352bf64d9d155">sm_op</a> == sm_start_oper ||
<a name="l00826"></a>00826               dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#7986bc3d4adf6769d8bbfc26d6ad55b9">from_action</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#870ffbe025aeb52318e352bf64d9d155">sm_op</a> == sm_stop_oper)
<a name="l00827"></a>00827             <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#788482acf72fd688418e5d4560967a4a">SM_ignore_dep</a> (dep_in, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#9ad2806dd5b02ac768ecbe8153eb871a">SM_MVE_IGNORE</a>);
<a name="l00828"></a>00828         }
<a name="l00829"></a>00829     }
<a name="l00830"></a>00830   <span class="keywordflow">for</span> (action = sm_stop_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#57586b443ee0ac219ebbdec855fd410d">first_op_action</a>; action != NULL;
<a name="l00831"></a>00831        action = action-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#006ea32b06272e80d00b880e2858a926">next_op_action</a>)
<a name="l00832"></a>00832     {
<a name="l00833"></a>00833       <span class="keywordflow">for</span> (dep_in = action-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#60b920d4ec6481af314c5d8a35b08e41">first_dep_in</a>; dep_in != NULL;
<a name="l00834"></a>00834            dep_in = dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#7db7e3db6b52d38f70d0a5e6d0b28b31">next_dep_in</a>)
<a name="l00835"></a>00835         {
<a name="l00836"></a>00836           <span class="keywordflow">if</span> (dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#7986bc3d4adf6769d8bbfc26d6ad55b9">from_action</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#870ffbe025aeb52318e352bf64d9d155">sm_op</a> == sm_start_oper ||
<a name="l00837"></a>00837               dep_in-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Dep.html#7986bc3d4adf6769d8bbfc26d6ad55b9">from_action</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Reg__Action.html#870ffbe025aeb52318e352bf64d9d155">sm_op</a> == sm_stop_oper)
<a name="l00838"></a>00838             <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#788482acf72fd688418e5d4560967a4a">SM_ignore_dep</a> (dep_in, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#9ad2806dd5b02ac768ecbe8153eb871a">SM_MVE_IGNORE</a>);
<a name="l00839"></a>00839         }
<a name="l00840"></a>00840     }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   <span class="comment">/* add a flow dependence from start node to all other opers and from</span>
<a name="l00843"></a>00843 <span class="comment">     all other opers to stop node */</span>
<a name="l00844"></a>00844   <span class="keywordflow">for</span> (sm_oper = sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#a89868f9a5bb0dabe28a9c74d44a6286">first_serial_op</a>; sm_oper != NULL;
<a name="l00845"></a>00845        sm_oper = sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#c7c35fc98ddf3d343118f16a6bfd0f99">next_serial_op</a>)
<a name="l00846"></a>00846     {
<a name="l00847"></a>00847       <span class="keywordflow">if</span> ((sm_oper == sm_start_oper) || (sm_oper == sm_stop_oper))
<a name="l00848"></a>00848         <span class="keywordflow">continue</span>;
<a name="l00849"></a>00849 
<a name="l00850"></a>00850       <span class="comment">/* Make a sync source so that a sync dep can </span>
<a name="l00851"></a>00851 <span class="comment">         originate from this instr. */</span>
<a name="l00852"></a>00852       <span class="keywordflow">if</span> (sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#fc6e609ae82e06f3089cb4206909e6ba">ext_dest</a>[<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>] == NULL)
<a name="l00853"></a>00853         {
<a name="l00854"></a>00854           sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#fc6e609ae82e06f3089cb4206909e6ba">ext_dest</a>[<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>] =
<a name="l00855"></a>00855             <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#ccb8edcd77ee94f72aa7c5fa774f2a0f">SM_add_reg_action</a> (sm_oper, <a class="codeRef" doxygen="liblmdes.tag:../../../../machine/Lmdes/html/" href="../../../../machine/Lmdes/html/lmdes_8h.html#8d186a9d28efc70dbedced22702e23f8">MDES_SYNC_OUT</a>, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>,
<a name="l00856"></a>00856                                <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#5fdcbaa2b827ff4ae58c4631ebd137f6">SM_SYNC_ACTION_OPERAND</a>);
<a name="l00857"></a>00857         }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859       <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#c0ba8409ca8be6d55eda19c7122a3c14">SM_add_dep</a> (sm_start_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#fc6e609ae82e06f3089cb4206909e6ba">ext_dest</a>[<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>],
<a name="l00860"></a>00860                   sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#b28625350558f9e8c88d1fa132c12cd7">ext_src</a>[<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>],
<a name="l00861"></a>00861                   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#3c42592e8b3fba29b7cacfc3f6edd0d4">SM_FIXED_DELAY</a> | <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#a132aa599b30be8d2dc30e17911a04be">SM_HARD_DEP</a> |
<a name="l00862"></a>00862                   SM_START_STOP_DEP | <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#a312013962761455a622b093085a6176">SM_FLOW_DEP</a> | <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#995c3ac7e1b553bb6826ce86befe1965">SM_SYNC_DEP</a>, 0, 0, 0,
<a name="l00863"></a>00863                   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#a132aa599b30be8d2dc30e17911a04be">SM_HARD_DEP</a> | <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#bff4fbec1ce79ed404423ab2eb6183fe">SM_SOFT_DEP</a>);
<a name="l00864"></a>00864       <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#c0ba8409ca8be6d55eda19c7122a3c14">SM_add_dep</a> (sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#fc6e609ae82e06f3089cb4206909e6ba">ext_dest</a>[<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>],
<a name="l00865"></a>00865                   sm_stop_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#b28625350558f9e8c88d1fa132c12cd7">ext_src</a>[<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#8c681e935d56a8858a44b3ecd45118a6">SM_SYNC_ACTION_INDEX</a>],
<a name="l00866"></a>00866                   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#3c42592e8b3fba29b7cacfc3f6edd0d4">SM_FIXED_DELAY</a> | <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#a132aa599b30be8d2dc30e17911a04be">SM_HARD_DEP</a> |
<a name="l00867"></a>00867                   SM_START_STOP_DEP | <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#a312013962761455a622b093085a6176">SM_FLOW_DEP</a> | <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#995c3ac7e1b553bb6826ce86befe1965">SM_SYNC_DEP</a>, 0, 0, 0,
<a name="l00868"></a>00868                   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#a132aa599b30be8d2dc30e17911a04be">SM_HARD_DEP</a> | <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#bff4fbec1ce79ed404423ab2eb6183fe">SM_SOFT_DEP</a>);
<a name="l00869"></a>00869     }
<a name="l00870"></a>00870 }
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="comment">/* delete start and stop pseudo-nodes and their associated dependences  */</span>
<a name="l00874"></a>00874 <span class="keywordtype">void</span>
<a name="l00875"></a><a class="code" href="l__pipe__util_8h.html#2d5b9cca606c59bc37fc608efa6284c2">00875</a> <a class="code" href="l__pipe__util_8c.html#e21d164bb9d5070bbf1f2250d5d27501">Lpipe_delete_start_stop_nodes</a> (<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html">SM_Cb</a> * sm_cb)
<a name="l00876"></a>00876 {
<a name="l00877"></a>00877   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *sm_oper;
<a name="l00878"></a>00878   L_Cb *lcode_cb;
<a name="l00879"></a>00879   L_Oper *lcode_op;
<a name="l00880"></a>00880 
<a name="l00881"></a>00881   sm_oper = sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#a89868f9a5bb0dabe28a9c74d44a6286">first_serial_op</a>;
<a name="l00882"></a>00882 
<a name="l00883"></a>00883   <span class="keywordflow">while</span> (sm_oper)
<a name="l00884"></a>00884     {
<a name="l00885"></a>00885       <span class="keywordflow">if</span> (L_START_STOP_NODE (sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>))
<a name="l00886"></a>00886         {
<a name="l00887"></a>00887           <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *next_serial_oper = sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#c7c35fc98ddf3d343118f16a6bfd0f99">next_serial_op</a>;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889           <span class="comment">/* 20030110 SZU</span>
<a name="l00890"></a>00890 <span class="comment">           * Memory problems.</span>
<a name="l00891"></a>00891 <span class="comment">           * SM_delete_oper tries to delete mdes_info in lcode_op.</span>
<a name="l00892"></a>00892 <span class="comment">           * However lcode_op is already gone via L_delete_oper.</span>
<a name="l00893"></a>00893 <span class="comment">           * Therefore save lcode_op and delete sm_oper first.</span>
<a name="l00894"></a>00894 <span class="comment">           * Also need to delete softpipe_op_info from lcode_op.</span>
<a name="l00895"></a>00895 <span class="comment">           */</span>
<a name="l00896"></a>00896 <span class="preprocessor">#if 0</span>
<a name="l00897"></a>00897 <span class="preprocessor"></span>          <span class="comment">/* Remove the lcode op from the cb */</span>
<a name="l00898"></a>00898           L_delete_oper (sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#403cdc247cfbc617d985413b7ecd95cb">sm_cb</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#b69cef60244b3cc923619329b3f8e622">lcode_cb</a>, sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>);
<a name="l00899"></a>00899 
<a name="l00900"></a>00900           <span class="comment">/* Delete the sm_op */</span>
<a name="l00901"></a>00901           <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8c.html#0883cb5cc83db52dddea8ba365807322">SM_delete_oper</a> (sm_oper);
<a name="l00902"></a>00902 <span class="preprocessor">#else</span>
<a name="l00903"></a>00903 <span class="preprocessor"></span>          lcode_cb = sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#403cdc247cfbc617d985413b7ecd95cb">sm_cb</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#b69cef60244b3cc923619329b3f8e622">lcode_cb</a>;
<a name="l00904"></a>00904           lcode_op = sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906           <span class="comment">/* Delete the sm_op */</span>
<a name="l00907"></a>00907           <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8c.html#0883cb5cc83db52dddea8ba365807322">SM_delete_oper</a> (sm_oper);
<a name="l00908"></a>00908 
<a name="l00909"></a>00909           <a class="code" href="l__softpipe__info_8c.html#070ce57374be3f0dd0db1e026e5f019c">Lpipe_free_oper_op_info</a> (lcode_op);
<a name="l00910"></a>00910 
<a name="l00911"></a>00911           <span class="comment">/* Remove the lcode op from the cb */</span>
<a name="l00912"></a>00912           L_delete_oper (lcode_cb, lcode_op);
<a name="l00913"></a>00913 <span class="preprocessor">#endif</span>
<a name="l00914"></a>00914 <span class="preprocessor"></span>          sm_oper = next_serial_oper;
<a name="l00915"></a>00915         }
<a name="l00916"></a>00916       <span class="keywordflow">else</span>
<a name="l00917"></a>00917         sm_oper = sm_oper-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#c7c35fc98ddf3d343118f16a6bfd0f99">next_serial_op</a>;
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919 }
<a name="l00920"></a>00920 
<a name="l00921"></a>00921 
<a name="l00922"></a>00922 <span class="comment">/*************************************************************************</span>
<a name="l00923"></a>00923 <span class="comment">                Debug Function Definitions</span>
<a name="l00924"></a>00924 <span class="comment">*************************************************************************/</span>
<a name="l00925"></a>00925 
<a name="l00926"></a>00926 <span class="comment">/* print cb with isl attributes to show schedule */</span>
<a name="l00927"></a>00927 <span class="keywordtype">void</span>
<a name="l00928"></a><a class="code" href="l__pipe__util_8h.html#a981448442d5ada28f8005bc460a55e4">00928</a> <a class="code" href="l__pipe__util_8c.html#b586f12896d4906e0e7015d4ea36b61e">Lpipe_print_cb_schedule</a> (FILE * file, L_Func * fn, <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html">SM_Cb</a> * sm_cb)
<a name="l00929"></a>00929 {
<a name="l00930"></a>00930   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Qentry.html">SM_Oper_Qentry</a> *q_op;
<a name="l00931"></a>00931   <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html">SM_Oper</a> *sm_op;
<a name="l00932"></a>00932   L_Oper *lcode_op;
<a name="l00933"></a>00933   L_Attr *attr;
<a name="l00934"></a>00934   <span class="keywordtype">int</span> found_isl = 0;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936   <span class="keywordflow">if</span> (file == NULL)
<a name="l00937"></a>00937     {
<a name="l00938"></a>00938       L_punt (<span class="stringliteral">"Lpipe_print_cb_schedule: sched_file not open - "</span>
<a name="l00939"></a>00939               <span class="stringliteral">"function %s, cb %d\n"</span>, fn-&gt;name, <a class="code" href="l__softpipe_8c.html#91e84fa9645e4d3beb7b8b6c150da74b">header_cb</a>-&gt;id);
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="keywordflow">if</span> (sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#8e754744130161765df739d3f6ed648a">kernel_queue</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Queue.html#7045e014fcca8fcbde2a616ddcde1ba5">first_qentry</a> == NULL)
<a name="l00943"></a>00943     {
<a name="l00944"></a>00944       L_punt (<span class="stringliteral">"Lpipe_print_cb_schedule: "</span>
<a name="l00945"></a>00945               <span class="stringliteral">"kernel queue must be built before printing schedule; "</span>
<a name="l00946"></a>00946               <span class="stringliteral">"function %s, cb %d\n"</span>, fn-&gt;name, <a class="code" href="l__softpipe_8c.html#91e84fa9645e4d3beb7b8b6c150da74b">header_cb</a>-&gt;id);
<a name="l00947"></a>00947     }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949 
<a name="l00950"></a>00950   <span class="comment">/* Use the first kernel instruction as a test to see if the</span>
<a name="l00951"></a>00951 <span class="comment">     kernel scheduling information has been attached. */</span>
<a name="l00952"></a>00952   attr =
<a name="l00953"></a>00953     L_find_attr (sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#8e754744130161765df739d3f6ed648a">kernel_queue</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Queue.html#7045e014fcca8fcbde2a616ddcde1ba5">first_qentry</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Qentry.html#c7acbaad49f5d5dd9b0d9a20eab4ddc6">sm_op</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>-&gt;attr,
<a name="l00954"></a>00954                  <span class="stringliteral">"isl"</span>);
<a name="l00955"></a>00955   <span class="keywordflow">if</span> (attr != NULL)
<a name="l00956"></a>00956     found_isl = 1;
<a name="l00957"></a>00957 
<a name="l00958"></a>00958   <span class="comment">/* Attach isl attribute only when one doesn't already exist */</span>
<a name="l00959"></a>00959   <span class="keywordflow">if</span> (!found_isl)
<a name="l00960"></a>00960     {
<a name="l00961"></a>00961       q_op = sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#8e754744130161765df739d3f6ed648a">kernel_queue</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Queue.html#7045e014fcca8fcbde2a616ddcde1ba5">first_qentry</a>;
<a name="l00962"></a>00962       <span class="keywordflow">while</span> (q_op != NULL)
<a name="l00963"></a>00963         {
<a name="l00964"></a>00964           sm_op = q_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Qentry.html#c7acbaad49f5d5dd9b0d9a20eab4ddc6">sm_op</a>;
<a name="l00965"></a>00965 
<a name="l00966"></a>00966           <a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8c.html#4b07b52de68d6ffbaa5073b740d4b411">SM_attach_isl</a> (sm_op, 0);
<a name="l00967"></a>00967 
<a name="l00968"></a>00968           q_op = q_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Qentry.html#18f8ae6743db367a6e487fa74ac19dde">next_qentry</a>;
<a name="l00969"></a>00969         }
<a name="l00970"></a>00970     }
<a name="l00971"></a>00971 
<a name="l00972"></a>00972   L_print_cb (<a class="code" href="l__softpipe_8c.html#dfcefa1a772012ef80d3b8f14f3f150b">sched_file</a>, fn, sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#b69cef60244b3cc923619329b3f8e622">lcode_cb</a>);
<a name="l00973"></a>00973 
<a name="l00974"></a>00974   <span class="comment">/* remove isl attributes */</span>
<a name="l00975"></a>00975   <span class="keywordflow">if</span> (!found_isl)
<a name="l00976"></a>00976     {
<a name="l00977"></a>00977       q_op = sm_cb-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Cb.html#8e754744130161765df739d3f6ed648a">kernel_queue</a>-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Queue.html#7045e014fcca8fcbde2a616ddcde1ba5">first_qentry</a>;
<a name="l00978"></a>00978       <span class="keywordflow">while</span> (q_op != NULL)
<a name="l00979"></a>00979         {
<a name="l00980"></a>00980           sm_op = q_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Qentry.html#c7acbaad49f5d5dd9b0d9a20eab4ddc6">sm_op</a>;
<a name="l00981"></a>00981           lcode_op = sm_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper.html#3f5397d6d9a8bf4c7d31e4dd0219f6a9">lcode_op</a>;
<a name="l00982"></a>00982 
<a name="l00983"></a>00983           attr = L_find_attr (lcode_op-&gt;attr, <span class="stringliteral">"isl"</span>);
<a name="l00984"></a>00984           <span class="keywordflow">if</span> (attr == NULL)
<a name="l00985"></a>00985             {
<a name="l00986"></a>00986               L_punt (<span class="stringliteral">"Lpipe_print_cb_schedule: "</span>
<a name="l00987"></a>00987                       <span class="stringliteral">"isl attribute should not be null,"</span>
<a name="l00988"></a>00988                       <span class="stringliteral">"function = %s, oper = %d\n"</span>, fn-&gt;name, lcode_op-&gt;id);
<a name="l00989"></a>00989             }
<a name="l00990"></a>00990           lcode_op-&gt;attr = L_delete_attr (lcode_op-&gt;attr, attr);
<a name="l00991"></a>00991 
<a name="l00992"></a>00992           q_op = q_op-&gt;<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/structSM__Oper__Qentry.html#18f8ae6743db367a6e487fa74ac19dde">next_qentry</a>;
<a name="l00993"></a>00993         }
<a name="l00994"></a>00994     }
<a name="l00995"></a>00995 
<a name="l00996"></a>00996   fflush (<a class="code" href="l__softpipe_8c.html#dfcefa1a772012ef80d3b8f14f3f150b">sched_file</a>);
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   <span class="keywordflow">return</span>;
<a name="l00999"></a>00999 }
<a name="l01000"></a>01000 
<a name="l01001"></a>01001 <span class="keywordtype">void</span>
<a name="l01002"></a><a class="code" href="l__pipe__util_8h.html#ffea3cc897c410d1404e778a2337b577">01002</a> <a class="code" href="l__pipe__util_8c.html#689850f1f56bc56b23c950658e5aba87">Lpipe_create_defines</a> (L_Func * fn)
<a name="l01003"></a>01003 {
<a name="l01004"></a>01004   L_Cb *cb;
<a name="l01005"></a>01005   L_Oper *rot_reg_op;
<a name="l01006"></a>01006   <span class="keywordtype">int</span> int_rot_reg_base = -1, int_rot_reg_num = -1;
<a name="l01007"></a>01007   <span class="keywordtype">int</span> flt_rot_reg_base = -1, flt_rot_reg_num = -1;
<a name="l01008"></a>01008   <span class="keywordtype">int</span> dbl_rot_reg_base = -1, dbl_rot_reg_num = -1;
<a name="l01009"></a>01009   <span class="keywordtype">int</span> pred_rot_reg_base = -1, pred_rot_reg_num = -1;
<a name="l01010"></a>01010   <span class="keywordtype">int</span> int_cb_rot_reg_num = -1;
<a name="l01011"></a>01011   <span class="keywordtype">int</span> flt_cb_rot_reg_num = -1;
<a name="l01012"></a>01012   <span class="keywordtype">int</span> dbl_cb_rot_reg_num = -1;
<a name="l01013"></a>01013   <span class="keywordtype">int</span> pred_cb_rot_reg_num = -1;
<a name="l01014"></a>01014   <span class="keywordtype">int</span> int_fn_rot_reg_num = -1;
<a name="l01015"></a>01015   <span class="keywordtype">int</span> flt_fn_rot_reg_num = -1;
<a name="l01016"></a>01016   <span class="keywordtype">int</span> dbl_fn_rot_reg_num = -1;
<a name="l01017"></a>01017   <span class="keywordtype">int</span> pred_fn_rot_reg_num = -1;
<a name="l01018"></a>01018   <span class="keywordtype">int</span> i;
<a name="l01019"></a>01019   <span class="keywordtype">int</span> chunk;
<a name="l01020"></a>01020   <span class="keywordtype">int</span> native_ctype = <a class="codeRef" doxygen="libmspec.tag:../../../../machine/Mspec/html/" href="../../../../machine/Mspec/html/m__spec_8h.html#8a083ae12702137e4e8eefe2e8204b54">M_native_int_register_ctype</a> ();
<a name="l01021"></a>01021   L_Attr *fn_rr_attr = NULL, *cb_rr_attr = NULL;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023   <span class="comment">/* Retrieve the rotating registers. */</span>
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   fn_rr_attr = L_find_attr (L_fn-&gt;attr, <span class="stringliteral">"rr"</span>);
<a name="l01026"></a>01026   <span class="keywordflow">if</span> (fn_rr_attr == NULL)
<a name="l01027"></a>01027     L_punt (<span class="stringliteral">"Lpipe_create_defines: "</span>
<a name="l01028"></a>01028             <span class="stringliteral">"Function not marked with rotating register IDs."</span>);
<a name="l01029"></a>01029 
<a name="l01030"></a>01030   int_rot_reg_base = fn_rr_attr-&gt;field[0]-&gt;value.i;
<a name="l01031"></a>01031   int_fn_rot_reg_num = fn_rr_attr-&gt;field[1]-&gt;value.i;
<a name="l01032"></a>01032   flt_rot_reg_base = fn_rr_attr-&gt;field[2]-&gt;value.i;
<a name="l01033"></a>01033   flt_fn_rot_reg_num = fn_rr_attr-&gt;field[3]-&gt;value.i;
<a name="l01034"></a>01034   dbl_rot_reg_base = fn_rr_attr-&gt;field[4]-&gt;value.i;
<a name="l01035"></a>01035   dbl_fn_rot_reg_num = fn_rr_attr-&gt;field[5]-&gt;value.i;
<a name="l01036"></a>01036   pred_rot_reg_base = fn_rr_attr-&gt;field[6]-&gt;value.i;
<a name="l01037"></a>01037   pred_fn_rot_reg_num = fn_rr_attr-&gt;field[7]-&gt;value.i;
<a name="l01038"></a>01038 
<a name="l01039"></a>01039   <span class="comment">/* Round the requested number of rotating registers </span>
<a name="l01040"></a>01040 <span class="comment">     up to the next chunk boundary. */</span>
<a name="l01041"></a>01041 
<a name="l01042"></a>01042   <span class="keywordflow">if</span> (<a class="codeRef" doxygen="libmspec.tag:../../../../machine/Mspec/html/" href="../../../../machine/Mspec/html/m__spec_8h.html#459f82172b68fe91c09e0c89d4d55cfa">M_arch</a> != <a class="codeRef" doxygen="libmspec.tag:../../../../machine/Mspec/html/" href="../../../../machine/Mspec/html/m__spec_8h.html#87ce108f22b58ab0e2e9408702ced941">M_TAHOE</a>)
<a name="l01043"></a>01043     {
<a name="l01044"></a>01044       chunk = <a class="codeRef" doxygen="libregalloc.tag:../../Regalloc/html/" href="../../Regalloc/html/r__regbank_8c.html#9b9641eecc75dfc8834ee8b71dd338cf">R_get_rot_reg_alloc_multiple</a> (native_ctype);
<a name="l01045"></a>01045       <span class="keywordflow">if</span> (chunk &lt; 1)
<a name="l01046"></a>01046         L_punt (<span class="stringliteral">"Lpipe_create_defines: "</span>
<a name="l01047"></a>01047                 <span class="stringliteral">"Invalid integer rot reg chunk %d."</span>, chunk);
<a name="l01048"></a>01048       int_fn_rot_reg_num = ((int_fn_rot_reg_num + chunk - 1) / chunk) * chunk;
<a name="l01049"></a>01049 
<a name="l01050"></a>01050       chunk = <a class="codeRef" doxygen="libregalloc.tag:../../Regalloc/html/" href="../../Regalloc/html/r__regbank_8c.html#9b9641eecc75dfc8834ee8b71dd338cf">R_get_rot_reg_alloc_multiple</a> (L_CTYPE_DOUBLE);
<a name="l01051"></a>01051       <span class="keywordflow">if</span> (chunk &lt; 1)
<a name="l01052"></a>01052         L_punt (<span class="stringliteral">"Lpipe_create_defines: Invalid double rot reg chunk %d."</span>,
<a name="l01053"></a>01053                 chunk);
<a name="l01054"></a>01054       dbl_fn_rot_reg_num = ((dbl_fn_rot_reg_num + chunk - 1) / chunk) * chunk;
<a name="l01055"></a>01055 
<a name="l01056"></a>01056       chunk = <a class="codeRef" doxygen="libregalloc.tag:../../Regalloc/html/" href="../../Regalloc/html/r__regbank_8c.html#9b9641eecc75dfc8834ee8b71dd338cf">R_get_rot_reg_alloc_multiple</a> (L_CTYPE_PREDICATE);
<a name="l01057"></a>01057       <span class="keywordflow">if</span> (chunk &lt; 1)
<a name="l01058"></a>01058         L_punt (<span class="stringliteral">"Lpipe_create_defines: Invalid predicate rot reg chunk %d."</span>,
<a name="l01059"></a>01059                 chunk);
<a name="l01060"></a>01060       pred_fn_rot_reg_num = ((pred_fn_rot_reg_num + chunk - 1) / chunk) *
<a name="l01061"></a>01061         chunk;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063       fn_rr_attr-&gt;field[1]-&gt;value.i = int_fn_rot_reg_num;
<a name="l01064"></a>01064       fn_rr_attr-&gt;field[5]-&gt;value.i = dbl_fn_rot_reg_num;
<a name="l01065"></a>01065       fn_rr_attr-&gt;field[7]-&gt;value.i = pred_fn_rot_reg_num;
<a name="l01066"></a>01066     }
<a name="l01067"></a>01067   <span class="keywordflow">else</span>
<a name="l01068"></a>01068     {
<a name="l01069"></a>01069       <span class="comment">/* Round the number of ints up to the multiple. */</span>
<a name="l01070"></a>01070 
<a name="l01071"></a>01071       chunk = 8;
<a name="l01072"></a>01072       int_fn_rot_reg_num = ((int_fn_rot_reg_num + chunk - 1) / chunk) * chunk;
<a name="l01073"></a>01073       fn_rr_attr-&gt;field[1]-&gt;value.i = int_fn_rot_reg_num;
<a name="l01074"></a>01074 
<a name="l01075"></a>01075       <span class="comment">/* The number of doubles and predicates are fixed</span>
<a name="l01076"></a>01076 <span class="comment">         and do not need to be rounded on Tahoe. */</span>
<a name="l01077"></a>01077     }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079   <span class="comment">/* Create the defines that ensure proper live range analysis of </span>
<a name="l01080"></a>01080 <span class="comment">     the rotating regs. */</span>
<a name="l01081"></a>01081 
<a name="l01082"></a>01082   <span class="keywordflow">for</span> (cb = fn-&gt;first_cb; cb != NULL; cb = cb-&gt;next_cb)
<a name="l01083"></a>01083     {
<a name="l01084"></a>01084       <span class="comment">/* This is a kernel that uses rotating registers.</span>
<a name="l01085"></a>01085 <span class="comment">         Create a temporary define instruction that will read </span>
<a name="l01086"></a>01086 <span class="comment">         and write all of the rotating registers.  This will</span>
<a name="l01087"></a>01087 <span class="comment">         ensure a live in condition from the prologue</span>
<a name="l01088"></a>01088 <span class="comment">         a live out condition from all of the exits. */</span>
<a name="l01089"></a>01089 
<a name="l01090"></a>01090       <span class="keywordflow">if</span> (L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_SOFTPIPE) &amp;&amp;
<a name="l01091"></a>01091           L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_ROT_REG_ALLOCATED))
<a name="l01092"></a>01092         {
<a name="l01093"></a>01093           cb_rr_attr = L_find_attr (cb-&gt;attr, <span class="stringliteral">"rr"</span>);
<a name="l01094"></a>01094           <span class="keywordflow">if</span> (cb_rr_attr == NULL)
<a name="l01095"></a>01095             L_punt (<span class="stringliteral">"Lpipe_create_defines: "</span>
<a name="l01096"></a>01096                     <span class="stringliteral">"Kernel cb not marked with rotating register IDs."</span>);
<a name="l01097"></a>01097           int_cb_rot_reg_num = cb_rr_attr-&gt;field[0]-&gt;value.i;
<a name="l01098"></a>01098           flt_cb_rot_reg_num = cb_rr_attr-&gt;field[1]-&gt;value.i;
<a name="l01099"></a>01099           dbl_cb_rot_reg_num = cb_rr_attr-&gt;field[2]-&gt;value.i;
<a name="l01100"></a>01100           pred_cb_rot_reg_num = cb_rr_attr-&gt;field[3]-&gt;value.i;
<a name="l01101"></a>01101         }
<a name="l01102"></a>01102       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_ROT_REG_ALLOCATED) &amp;&amp;
<a name="l01103"></a>01103                L_find_attr (cb-&gt;attr, <span class="stringliteral">"prologue"</span>) != NULL)
<a name="l01104"></a>01104         {
<a name="l01105"></a>01105           <span class="keywordflow">if</span> (cb-&gt;next_cb == NULL)
<a name="l01106"></a>01106             L_punt (<span class="stringliteral">"Lpipe_create_defines: "</span>
<a name="l01107"></a>01107                     <span class="stringliteral">"Kernel cb not found after prologue cb (1)."</span>);
<a name="l01108"></a>01108 
<a name="l01109"></a>01109           <span class="keywordflow">if</span> (L_EXTRACT_BIT_VAL (cb-&gt;next_cb-&gt;flags, L_CB_SOFTPIPE) &amp;&amp;
<a name="l01110"></a>01110               L_EXTRACT_BIT_VAL (cb-&gt;next_cb-&gt;flags, L_CB_ROT_REG_ALLOCATED))
<a name="l01111"></a>01111             {
<a name="l01112"></a>01112               cb_rr_attr = L_find_attr (cb-&gt;next_cb-&gt;attr, <span class="stringliteral">"rr"</span>);
<a name="l01113"></a>01113               <span class="keywordflow">if</span> (cb_rr_attr == NULL)
<a name="l01114"></a>01114                 L_punt (<span class="stringliteral">"Lpipe_create_defines: "</span>
<a name="l01115"></a>01115                         <span class="stringliteral">"Kernel cb not marked with rotating register IDs."</span>);
<a name="l01116"></a>01116               int_cb_rot_reg_num = cb_rr_attr-&gt;field[0]-&gt;value.i;
<a name="l01117"></a>01117               flt_cb_rot_reg_num = cb_rr_attr-&gt;field[1]-&gt;value.i;
<a name="l01118"></a>01118               dbl_cb_rot_reg_num = cb_rr_attr-&gt;field[2]-&gt;value.i;
<a name="l01119"></a>01119               pred_cb_rot_reg_num = cb_rr_attr-&gt;field[3]-&gt;value.i;
<a name="l01120"></a>01120             }
<a name="l01121"></a>01121           <span class="keywordflow">else</span>
<a name="l01122"></a>01122             L_punt (<span class="stringliteral">"Lpipe_create_defines: "</span>
<a name="l01123"></a>01123                     <span class="stringliteral">"Kernel cb not found after prologue cb (2)."</span>);
<a name="l01124"></a>01124         }
<a name="l01125"></a>01125       <span class="keywordflow">else</span>
<a name="l01126"></a>01126         {
<a name="l01127"></a>01127           <span class="keywordflow">continue</span>;
<a name="l01128"></a>01128         }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130       <span class="comment">/* Determine the registers that must be preserved. */</span>
<a name="l01131"></a>01131 
<a name="l01132"></a>01132       int_rot_reg_num = int_fn_rot_reg_num;
<a name="l01133"></a>01133       <span class="comment">/* The number of flts and dbls and preds is fixed.</span>
<a name="l01134"></a>01134 <span class="comment">         However, alloc the cb doubles first, then the </span>
<a name="l01135"></a>01135 <span class="comment">         cb float then pad the floats to the end of the bank. */</span>
<a name="l01136"></a>01136       dbl_rot_reg_num = dbl_fn_rot_reg_num;
<a name="l01137"></a>01137 <span class="preprocessor">#if 0</span>
<a name="l01138"></a>01138 <span class="preprocessor"></span>      flt_rot_reg_num = flt_fn_rot_reg_num - dbl_cb_rot_reg_num;
<a name="l01139"></a>01139 <span class="preprocessor">#endif</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span>      pred_rot_reg_num = pred_fn_rot_reg_num;
<a name="l01141"></a>01141 
<a name="l01142"></a>01142       <span class="comment">/* Insert the defines depending on the type of cb. */</span>
<a name="l01143"></a>01143 
<a name="l01144"></a>01144       <span class="keywordflow">if</span> (L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_SOFTPIPE) &amp;&amp;
<a name="l01145"></a>01145           L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_ROT_REG_ALLOCATED))
<a name="l01146"></a>01146         {
<a name="l01147"></a>01147           <span class="keywordflow">for</span> (i = int_rot_reg_base;
<a name="l01148"></a>01148                i &lt; int_rot_reg_base + int_rot_reg_num; i++)
<a name="l01149"></a>01149             {
<a name="l01150"></a>01150               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01151"></a>01151               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01152"></a>01152               L_insert_oper_before (cb, cb-&gt;first_op, rot_reg_op);
<a name="l01153"></a>01153               rot_reg_op-&gt;dest[0] =
<a name="l01154"></a>01154                 L_new_register_operand (i, native_ctype, L_PTYPE_NULL);
<a name="l01155"></a>01155               rot_reg_op-&gt;src[0] =
<a name="l01156"></a>01156                 L_new_register_operand (i, native_ctype, L_PTYPE_NULL);
<a name="l01157"></a>01157               L_insert_oper_before (cb, cb-&gt;last_op,
<a name="l01158"></a>01158                                     L_copy_operation (rot_reg_op));
<a name="l01159"></a>01159             }
<a name="l01160"></a>01160           <span class="keywordflow">for</span> (i = flt_rot_reg_base;
<a name="l01161"></a>01161                i &lt; flt_rot_reg_base + flt_rot_reg_num; i++)
<a name="l01162"></a>01162             {
<a name="l01163"></a>01163               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01164"></a>01164               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01165"></a>01165               L_insert_oper_before (cb, cb-&gt;first_op, rot_reg_op);
<a name="l01166"></a>01166               rot_reg_op-&gt;dest[0] =
<a name="l01167"></a>01167                 L_new_register_operand (i, L_CTYPE_FLOAT, L_PTYPE_NULL);
<a name="l01168"></a>01168               rot_reg_op-&gt;src[0] =
<a name="l01169"></a>01169                 L_new_register_operand (i, L_CTYPE_FLOAT, L_PTYPE_NULL);
<a name="l01170"></a>01170               L_insert_oper_before (cb, cb-&gt;last_op,
<a name="l01171"></a>01171                                     L_copy_operation (rot_reg_op));
<a name="l01172"></a>01172             }
<a name="l01173"></a>01173           <span class="keywordflow">for</span> (i = dbl_rot_reg_base;
<a name="l01174"></a>01174                i &lt; dbl_rot_reg_base + dbl_rot_reg_num; i++)
<a name="l01175"></a>01175             {
<a name="l01176"></a>01176               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01177"></a>01177               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01178"></a>01178               L_insert_oper_before (cb, cb-&gt;first_op, rot_reg_op);
<a name="l01179"></a>01179               rot_reg_op-&gt;dest[0] =
<a name="l01180"></a>01180                 L_new_register_operand (i, L_CTYPE_DOUBLE, L_PTYPE_NULL);
<a name="l01181"></a>01181               rot_reg_op-&gt;src[0] =
<a name="l01182"></a>01182                 L_new_register_operand (i, L_CTYPE_DOUBLE, L_PTYPE_NULL);
<a name="l01183"></a>01183               L_insert_oper_before (cb, cb-&gt;last_op,
<a name="l01184"></a>01184                                     L_copy_operation (rot_reg_op));
<a name="l01185"></a>01185             }
<a name="l01186"></a>01186           <span class="keywordflow">for</span> (i = pred_rot_reg_base;
<a name="l01187"></a>01187                i &lt; pred_rot_reg_base + pred_rot_reg_num; i++)
<a name="l01188"></a>01188             {
<a name="l01189"></a>01189               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01190"></a>01190               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01191"></a>01191               L_insert_oper_before (cb, cb-&gt;first_op, rot_reg_op);
<a name="l01192"></a>01192               rot_reg_op-&gt;dest[0] =
<a name="l01193"></a>01193                 L_new_register_operand (i, L_CTYPE_PREDICATE,
<a name="l01194"></a>01194                                         L_PTYPE_UNCOND_T);
<a name="l01195"></a>01195               rot_reg_op-&gt;src[0] =
<a name="l01196"></a>01196                 L_new_register_operand (i, L_CTYPE_PREDICATE, L_PTYPE_NULL);
<a name="l01197"></a>01197               L_insert_oper_before (cb, cb-&gt;last_op,
<a name="l01198"></a>01198                                     L_copy_operation (rot_reg_op));
<a name="l01199"></a>01199             }
<a name="l01200"></a>01200           <span class="keywordflow">if</span> (<a class="codeRef" doxygen="libmspec.tag:../../../../machine/Mspec/html/" href="../../../../machine/Mspec/html/m__spec_8h.html#459f82172b68fe91c09e0c89d4d55cfa">M_arch</a> == <a class="codeRef" doxygen="libmspec.tag:../../../../machine/Mspec/html/" href="../../../../machine/Mspec/html/m__spec_8h.html#87ce108f22b58ab0e2e9408702ced941">M_TAHOE</a>)
<a name="l01201"></a>01201             {
<a name="l01202"></a>01202               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01203"></a>01203               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01204"></a>01204               L_insert_oper_before (cb, cb-&gt;last_op, rot_reg_op);
<a name="l01205"></a>01205               rot_reg_op-&gt;src[0] = <a class="codeRef" doxygen="libmspec.tag:../../../../machine/Mspec/html/" href="../../../../machine/Mspec/html/m__spec_8h.html#462adaf13d377690c81f298e03f04687">M_return_epilogue_cntr_register</a> ();
<a name="l01206"></a>01206             }
<a name="l01207"></a>01207         }
<a name="l01208"></a>01208       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_ROT_REG_ALLOCATED) &amp;&amp;
<a name="l01209"></a>01209                L_find_attr (cb-&gt;attr, <span class="stringliteral">"prologue"</span>) != NULL)
<a name="l01210"></a>01210         {
<a name="l01211"></a>01211           <span class="comment">/* This is a prologue that uses rotating registers.</span>
<a name="l01212"></a>01212 <span class="comment">             Create a temporary define instruction that will write</span>
<a name="l01213"></a>01213 <span class="comment">             all of the rotating registers.  This will ensure a live</span>
<a name="l01214"></a>01214 <span class="comment">             in condition from the prologue and a live out condition from</span>
<a name="l01215"></a>01215 <span class="comment">             all of the exits.  It will also prevent a live in</span>
<a name="l01216"></a>01216 <span class="comment">             condition from the epilogue of a predecessor software</span>
<a name="l01217"></a>01217 <span class="comment">             pipelined loop. */</span>
<a name="l01218"></a>01218           <span class="keywordflow">for</span> (i = int_rot_reg_base;
<a name="l01219"></a>01219                i &lt; int_rot_reg_base + int_rot_reg_num; i++)
<a name="l01220"></a>01220             {
<a name="l01221"></a>01221               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01222"></a>01222               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01223"></a>01223               L_insert_oper_before (cb, cb-&gt;first_op, rot_reg_op);
<a name="l01224"></a>01224               rot_reg_op-&gt;dest[0] =
<a name="l01225"></a>01225                 L_new_register_operand (i, native_ctype, L_PTYPE_NULL);
<a name="l01226"></a>01226             }
<a name="l01227"></a>01227           <span class="keywordflow">for</span> (i = flt_rot_reg_base;
<a name="l01228"></a>01228                i &lt; flt_rot_reg_base + flt_rot_reg_num; i++)
<a name="l01229"></a>01229             {
<a name="l01230"></a>01230               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01231"></a>01231               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01232"></a>01232               L_insert_oper_before (cb, cb-&gt;first_op, rot_reg_op);
<a name="l01233"></a>01233               rot_reg_op-&gt;dest[0] =
<a name="l01234"></a>01234                 L_new_register_operand (i, L_CTYPE_FLOAT, L_PTYPE_NULL);
<a name="l01235"></a>01235             }
<a name="l01236"></a>01236           <span class="keywordflow">for</span> (i = dbl_rot_reg_base;
<a name="l01237"></a>01237                i &lt; dbl_rot_reg_base + dbl_rot_reg_num; i++)
<a name="l01238"></a>01238             {
<a name="l01239"></a>01239               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01240"></a>01240               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01241"></a>01241               L_insert_oper_before (cb, cb-&gt;first_op, rot_reg_op);
<a name="l01242"></a>01242               rot_reg_op-&gt;dest[0] =
<a name="l01243"></a>01243                 L_new_register_operand (i, L_CTYPE_DOUBLE, L_PTYPE_NULL);
<a name="l01244"></a>01244             }
<a name="l01245"></a>01245           <span class="keywordflow">for</span> (i = pred_rot_reg_base;
<a name="l01246"></a>01246                i &lt; pred_rot_reg_base + pred_rot_reg_num; i++)
<a name="l01247"></a>01247             {
<a name="l01248"></a>01248               rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01249"></a>01249               L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01250"></a>01250               L_insert_oper_before (cb, cb-&gt;first_op, rot_reg_op);
<a name="l01251"></a>01251               rot_reg_op-&gt;dest[0] =
<a name="l01252"></a>01252                 L_new_register_operand (i, L_CTYPE_PREDICATE,
<a name="l01253"></a>01253                                         L_PTYPE_UNCOND_T);
<a name="l01254"></a>01254             }
<a name="l01255"></a>01255         }
<a name="l01256"></a>01256     }
<a name="l01257"></a>01257 }
<a name="l01258"></a>01258 
<a name="l01259"></a>01259 
<a name="l01260"></a>01260 <span class="keywordtype">void</span>
<a name="l01261"></a><a class="code" href="l__pipe__util_8h.html#09d06183dc0f6729b321b7e2c3c60699">01261</a> <a class="code" href="l__pipe__util_8c.html#e541b9878cec8748cd7882ee97c7ba4f">Lpipe_delete_defines</a> (L_Func * fn)
<a name="l01262"></a>01262 {
<a name="l01263"></a>01263   L_Cb *cb;
<a name="l01264"></a>01264   L_Oper *op, *delete_op;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266   <span class="comment">/* Scan for cbs that are software pipelines and utilize</span>
<a name="l01267"></a>01267 <span class="comment">     rotating registers. (L_CB_ROT_REG_ALLOCATED and L_CB_SOFTPIPE) */</span>
<a name="l01268"></a>01268 
<a name="l01269"></a>01269   <span class="keywordflow">for</span> (cb = fn-&gt;first_cb; cb != NULL; cb = cb-&gt;next_cb)
<a name="l01270"></a>01270     {
<a name="l01271"></a>01271       <span class="keywordflow">if</span> (L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_ROT_REG_ALLOCATED) == 1 &amp;&amp;
<a name="l01272"></a>01272           (L_EXTRACT_BIT_VAL (cb-&gt;flags, L_CB_SOFTPIPE) == 1 ||
<a name="l01273"></a>01273            L_find_attr (cb-&gt;attr, <span class="stringliteral">"prologue"</span>) != NULL))
<a name="l01274"></a>01274         {
<a name="l01275"></a>01275           op = cb-&gt;first_op;
<a name="l01276"></a>01276 
<a name="l01277"></a>01277           <span class="keywordflow">while</span> (op != NULL)
<a name="l01278"></a>01278             {
<a name="l01279"></a>01279               delete_op = op;
<a name="l01280"></a>01280               op = op-&gt;next_op;
<a name="l01281"></a>01281 
<a name="l01282"></a>01282               <span class="comment">/* 20031006 SZU</span>
<a name="l01283"></a>01283 <span class="comment">               * Need to preserve template ops</span>
<a name="l01284"></a>01284 <span class="comment">               */</span>
<a name="l01285"></a>01285               <span class="keywordflow">if</span> (delete_op-&gt;opc == Lop_DEFINE &amp;&amp; 
<a name="l01286"></a>01286                   !<a class="codeRef" doxygen="libsm.tag:../../../sched/SM/html/" href="../../../sched/SM/html/sm_8h.html#724d2ecec2dceac28b854fdc65fcd16f">M_is_template_op</a> (delete_op))
<a name="l01287"></a>01287                 L_delete_oper (cb, delete_op);
<a name="l01288"></a>01288             }
<a name="l01289"></a>01289         }
<a name="l01290"></a>01290     }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292   <span class="keywordflow">return</span>;
<a name="l01293"></a>01293 }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 <span class="keywordtype">void</span>
<a name="l01296"></a><a class="code" href="l__pipe__util_8h.html#1717d05a7fa2b065c482d5476745d580">01296</a> <a class="code" href="l__pipe__util_8c.html#1717d05a7fa2b065c482d5476745d580">Lpipe_print_cyclic_stats</a> (FILE * <a class="code" href="l__softpipe_8c.html#bfb992b8633f7de2f771384a01c7411e">gen_statfile</a>, L_Cb * <a class="code" href="l__softpipe_8c.html#91e84fa9645e4d3beb7b8b6c150da74b">header_cb</a>,
<a name="l01297"></a>01297                           Softpipe_MinII * MinII, <span class="keywordtype">int</span> ii, <span class="keywordtype">int</span> tries,
<a name="l01298"></a>01298                           <span class="keywordtype">int</span> schedule_length, <span class="keywordtype">int</span> <a class="code" href="l__softpipe_8c.html#4dc68702d9b52f9ccb3dc704c3382dad">loop_dep_height</a>,
<a name="l01299"></a>01299                           <span class="keywordtype">int</span> stage_count, <span class="keywordtype">int</span> unroll, <span class="keywordtype">int</span> theta,
<a name="l01300"></a>01300                           <span class="keywordtype">int</span> num_oper, <span class="keywordtype">int</span> branch_count, L_Inner_Loop * loop)
<a name="l01301"></a>01301 {
<a name="l01302"></a>01302   L_Attr *attr;
<a name="l01303"></a>01303   <span class="keywordtype">int</span> unroll_AMP;
<a name="l01304"></a>01304   <span class="keywordtype">float</span> mii_eff, ii_eff, ii_ratio;
<a name="l01305"></a>01305 
<a name="l01306"></a>01306   attr = L_new_attr (<span class="stringliteral">"II"</span>, 1);
<a name="l01307"></a>01307   L_set_int_attr_field (attr, 0, ii);
<a name="l01308"></a>01308   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01309"></a>01309   attr = L_new_attr (<span class="stringliteral">"tries"</span>, 1);
<a name="l01310"></a>01310   L_set_int_attr_field (attr, 0, tries);
<a name="l01311"></a>01311   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01312"></a>01312   attr = L_new_attr (<span class="stringliteral">"softpipe_schedule_length"</span>, 1);
<a name="l01313"></a>01313   L_set_int_attr_field (attr, 0, schedule_length);
<a name="l01314"></a>01314   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01315"></a>01315   attr = L_new_attr (<span class="stringliteral">"softpipe_loop_dep_height"</span>, 1);
<a name="l01316"></a>01316   L_set_int_attr_field (attr, 0, loop_dep_height);
<a name="l01317"></a>01317   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01318"></a>01318   attr = L_new_attr (<span class="stringliteral">"stage_count"</span>, 1);
<a name="l01319"></a>01319   L_set_int_attr_field (attr, 0, stage_count);
<a name="l01320"></a>01320   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01321"></a>01321   attr = L_new_attr (<span class="stringliteral">"useful_stage_count"</span>, 1);
<a name="l01322"></a>01322   L_set_float_attr_field (attr, 0, ((<span class="keywordtype">float</span>) schedule_length / (<span class="keywordtype">float</span>) ii));
<a name="l01323"></a>01323   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01324"></a>01324   attr = L_new_attr (<span class="stringliteral">"kmin"</span>, 1);
<a name="l01325"></a>01325   L_set_int_attr_field (attr, 0, unroll);
<a name="l01326"></a>01326   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01327"></a>01327   attr = L_new_attr (<span class="stringliteral">"theta"</span>, 1);
<a name="l01328"></a>01328   L_set_int_attr_field (attr, 0, theta);
<a name="l01329"></a>01329   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01330"></a>01330   attr = L_new_attr (<span class="stringliteral">"opers"</span>, 1);
<a name="l01331"></a>01331   L_set_int_attr_field (attr, 0, num_oper);
<a name="l01332"></a>01332   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01333"></a>01333   attr = L_new_attr (<span class="stringliteral">"branches"</span>, 1);
<a name="l01334"></a>01334   L_set_int_attr_field (attr, 0, branch_count);
<a name="l01335"></a>01335   header_cb-&gt;attr = L_concat_attr (header_cb-&gt;attr, attr);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337   unroll_AMP = 1;
<a name="l01338"></a>01338   attr = L_find_attr (header_cb-&gt;attr, <span class="stringliteral">"unroll_AMP"</span>);
<a name="l01339"></a>01339   <span class="keywordflow">if</span> (attr != NULL)
<a name="l01340"></a>01340     {
<a name="l01341"></a>01341       unroll_AMP = attr-&gt;field[0]-&gt;value.i;
<a name="l01342"></a>01342       mii_eff = ((float) MinII-&gt;MinII) / ((float) unroll_AMP);
<a name="l01343"></a>01343       ii_eff = ((float) ii) / ((float) unroll_AMP);
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345   <span class="keywordflow">else</span>
<a name="l01346"></a>01346     {
<a name="l01347"></a>01347       mii_eff = (float) MinII-&gt;MinII;
<a name="l01348"></a>01348       ii_eff = (<span class="keywordtype">float</span>) ii;
<a name="l01349"></a>01349     }
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   ii_ratio = ii_eff / mii_eff;
<a name="l01352"></a>01352   fprintf (gen_statfile, <span class="stringliteral">"ResMinII: %d\n"</span>, MinII-&gt;res_MinII);
<a name="l01353"></a>01353   fprintf (gen_statfile, <span class="stringliteral">"RecMinII: %d\n"</span>, MinII-&gt;rec_MinII);
<a name="l01354"></a>01354   fprintf (gen_statfile, <span class="stringliteral">"II: %d\n"</span>, ii);
<a name="l01355"></a>01355   fprintf (gen_statfile, <span class="stringliteral">"Prior_unroll: %d\n"</span>, unroll_AMP);
<a name="l01356"></a>01356   fprintf (gen_statfile, <span class="stringliteral">"MinII_eff: %f\n"</span>, mii_eff);
<a name="l01357"></a>01357   fprintf (gen_statfile, <span class="stringliteral">"II_eff: %f\n"</span>, ii_eff);
<a name="l01358"></a>01358   fprintf (gen_statfile, <span class="stringliteral">"II_MinII_ratio: %f\n"</span>, ii_ratio);
<a name="l01359"></a>01359   fprintf (gen_statfile, <span class="stringliteral">"Tries: %d\n"</span>, tries);
<a name="l01360"></a>01360   fprintf (gen_statfile, <span class="stringliteral">"Schedule_length: %d\n"</span>, schedule_length);
<a name="l01361"></a>01361   fprintf (gen_statfile, <span class="stringliteral">"Dependence_height: %d\n"</span>, loop_dep_height);
<a name="l01362"></a>01362   fprintf (gen_statfile, <span class="stringliteral">"Stage_count: %d\n"</span>, stage_count);
<a name="l01363"></a>01363   fprintf (gen_statfile, <span class="stringliteral">"Kmin: %d\n"</span>, unroll);
<a name="l01364"></a>01364   fprintf (gen_statfile, <span class="stringliteral">"Theta: %d\n"</span>, theta);
<a name="l01365"></a>01365   fprintf (gen_statfile, <span class="stringliteral">"Number_of_opers: %d\n"</span>, num_oper);
<a name="l01366"></a>01366   fprintf (gen_statfile, <span class="stringliteral">"Number_of_branches: %d\n"</span>, branch_count);
<a name="l01367"></a>01367   fprintf (gen_statfile, <span class="stringliteral">"Loop_freq: %f\n"</span>, header_cb-&gt;weight);
<a name="l01368"></a>01368   fprintf (gen_statfile, <span class="stringliteral">"Entry_freq: %f\n"</span>, loop-&gt;num_invocation);
<a name="l01369"></a>01369   fprintf (gen_statfile, <span class="stringliteral">"Budget_ratio: %f\n"</span>, <a class="code" href="l__pipe__util_8c.html#a50c2551f678955eabc6e79793268ffa">Lpipe_budget_ratio</a>);
<a name="l01370"></a>01370   <span class="keywordflow">return</span>;
<a name="l01371"></a>01371 }
<a name="l01372"></a>01372 
<a name="l01373"></a>01373 
<a name="l01374"></a>01374 L_Oper *
<a name="l01375"></a><a class="code" href="l__pipe__util_8h.html#da3a3357b8fde887ab841682e5ee9151">01375</a> <a class="code" href="l__pipe__util_8c.html#ee779950f38ef40325d91a06a673d9ae">Lpipe_gen_mov_consuming_operands</a> (L_Operand * dest, L_Operand * src)
<a name="l01376"></a>01376 {
<a name="l01377"></a>01377   L_Oper *new_oper;
<a name="l01378"></a>01378   <span class="keywordtype">int</span> opc = 0;
<a name="l01379"></a>01379 
<a name="l01380"></a>01380   <span class="keywordflow">if</span> (!dest || !src)
<a name="l01381"></a>01381     L_punt (<span class="stringliteral">"Lpipe_gen_mov: NULL operand"</span>);
<a name="l01382"></a>01382 
<a name="l01383"></a>01383   <span class="keywordflow">if</span> (L_is_ctype_integer (src))
<a name="l01384"></a>01384     opc = Lop_MOV;
<a name="l01385"></a>01385   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_is_ctype_flt (src))
<a name="l01386"></a>01386     opc = Lop_MOV_F;
<a name="l01387"></a>01387   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_is_ctype_dbl (src))
<a name="l01388"></a>01388     opc = Lop_MOV_F2;
<a name="l01389"></a>01389   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (L_is_ctype_predicate (src))
<a name="l01390"></a>01390     opc = Lop_CMP;
<a name="l01391"></a>01391   <span class="keywordflow">else</span>
<a name="l01392"></a>01392     L_punt (<span class="stringliteral">"Lpipe_gen_mov: Unhandled type"</span>);
<a name="l01393"></a>01393 
<a name="l01394"></a>01394   new_oper = L_create_new_op (opc);
<a name="l01395"></a>01395   new_oper-&gt;dest[0] = dest;
<a name="l01396"></a>01396   <span class="keywordflow">if</span> (opc != Lop_CMP)
<a name="l01397"></a>01397     {
<a name="l01398"></a>01398       new_oper-&gt;src[0] = src;
<a name="l01399"></a>01399     }
<a name="l01400"></a>01400   <span class="keywordflow">else</span>
<a name="l01401"></a>01401     {
<a name="l01402"></a>01402       new_oper-&gt;pred[0] = src;
<a name="l01403"></a>01403       L_set_compare (new_oper, L_CTYPE_INT, Lcmp_COM_EQ);
<a name="l01404"></a>01404       L_assign_ptype_uncond_true (new_oper-&gt;dest[0]);
<a name="l01405"></a>01405       new_oper-&gt;src[0] = L_new_gen_int_operand (0);
<a name="l01406"></a>01406       new_oper-&gt;src[1] = L_new_gen_int_operand (0);
<a name="l01407"></a>01407     }
<a name="l01408"></a>01408 
<a name="l01409"></a>01409   <span class="keywordflow">return</span> new_oper;
<a name="l01410"></a>01410 }
<a name="l01411"></a>01411 
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 <span class="keywordtype">void</span>
<a name="l01414"></a><a class="code" href="l__softpipe_8h.html#bc532cb244121a0e4179f7d989a94f9e">01414</a> <a class="code" href="l__pipe__util_8c.html#b17b99684ef3a58402ade4ddb0129407">Lpipe_move_int_parm_regs</a> (L_Func * fn)
<a name="l01415"></a>01415 {
<a name="l01416"></a>01416   L_Attr *tr_attr;
<a name="l01417"></a>01417   <span class="keywordtype">int</span> fields, j, pipelined = 0;
<a name="l01418"></a>01418   L_Operand *parm_operand, *parm_class_operand, *parm_vreg;
<a name="l01419"></a>01419   L_Oper *alloc_op, *insert_before_op, *scan_op, *move_op;
<a name="l01420"></a>01420   L_Cb *scan_cb;
<a name="l01421"></a>01421   <span class="keywordtype">int</span> native_ctype = <a class="codeRef" doxygen="libmspec.tag:../../../../machine/Mspec/html/" href="../../../../machine/Mspec/html/m__spec_8h.html#8a083ae12702137e4e8eefe2e8204b54">M_native_int_register_ctype</a> ();
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   tr_attr = L_find_attr (fn-&gt;attr, <span class="stringliteral">"tr"</span>);
<a name="l01424"></a>01424 
<a name="l01425"></a>01425   scan_cb = fn-&gt;first_cb;
<a name="l01426"></a>01426   <span class="keywordflow">while</span> (scan_cb &amp;&amp; pipelined == 0)
<a name="l01427"></a>01427     {
<a name="l01428"></a>01428       pipelined |= L_EXTRACT_BIT_VAL (scan_cb-&gt;flags, L_CB_SOFTPIPE);
<a name="l01429"></a>01429       scan_cb = scan_cb-&gt;next_cb;
<a name="l01430"></a>01430     }
<a name="l01431"></a>01431 
<a name="l01432"></a>01432   <span class="comment">/* If there are input parms and there are pipelined loops, then</span>
<a name="l01433"></a>01433 <span class="comment">     move the input parms into virtual registers. */</span>
<a name="l01434"></a>01434   <span class="keywordflow">if</span> (tr_attr != NULL &amp;&amp; pipelined == 1)
<a name="l01435"></a>01435     {
<a name="l01436"></a>01436       <span class="comment">/* Find the prologue or alloc instruction. */</span>
<a name="l01437"></a>01437       alloc_op = fn-&gt;first_cb-&gt;first_op;
<a name="l01438"></a>01438       <span class="keywordflow">while</span> (alloc_op != NULL &amp;&amp; alloc_op-&gt;opc != Lop_ALLOC)
<a name="l01439"></a>01439         {
<a name="l01440"></a>01440           alloc_op = alloc_op-&gt;next_op;
<a name="l01441"></a>01441         }
<a name="l01442"></a>01442       <span class="keywordflow">if</span> (!alloc_op)
<a name="l01443"></a>01443         L_punt (<span class="stringliteral">"Lpipe_move_int_parm_regs: function prologue op not found."</span>);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445       insert_before_op = alloc_op-&gt;next_op;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447       <span class="comment">/* Loop through the incoming register parameters. */</span>
<a name="l01448"></a>01448       <span class="keywordflow">for</span> (fields = 0; fields &lt; tr_attr-&gt;max_field; fields++)
<a name="l01449"></a>01449         {
<a name="l01450"></a>01450           parm_operand = tr_attr-&gt;field[fields];
<a name="l01451"></a>01451           if (!L_is_macro (parm_operand))
<a name="l01452"></a>01452             L_punt (<span class="stringliteral">"Lpipe_move_int_parm_regs: "</span>
<a name="l01453"></a>01453                     <span class="stringliteral">"parm in tr field is not a macro."</span>);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455           <span class="keywordflow">if</span> (!L_is_ctype_integer (parm_operand))
<a name="l01456"></a>01456             <span class="keywordflow">continue</span>;
<a name="l01457"></a>01457 
<a name="l01458"></a>01458           <span class="comment">/* Generate the move into a vreg. */</span>
<a name="l01459"></a>01459           parm_vreg = L_new_register_operand (++(fn-&gt;max_reg_id),
<a name="l01460"></a>01460                                               native_ctype, L_PTYPE_NULL);
<a name="l01461"></a>01461           parm_class_operand = L_new_macro_operand (parm_operand-&gt;value.mac,
<a name="l01462"></a>01462                                                     native_ctype,
<a name="l01463"></a>01463                                                     L_PTYPE_NULL);
<a name="l01464"></a>01464 
<a name="l01465"></a>01465           move_op =
<a name="l01466"></a>01466             <a class="code" href="l__pipe__util_8c.html#ee779950f38ef40325d91a06a673d9ae">Lpipe_gen_mov_consuming_operands</a> (L_copy_operand (parm_vreg),
<a name="l01467"></a>01467                                               L_copy_operand
<a name="l01468"></a>01468                                               (parm_class_operand));
<a name="l01469"></a>01469           L_insert_oper_before (fn-&gt;first_cb, insert_before_op, move_op);
<a name="l01470"></a>01470           <a class="code" href="l__softpipe_8h.html#fd8def20f61a7cd2a65cd6f3e89f233f">L_annotate_oper</a> (fn, fn-&gt;first_cb, move_op);
<a name="l01471"></a>01471           L_delete_oper (fn-&gt;first_cb, move_op);
<a name="l01472"></a>01472 
<a name="l01473"></a>01473           <span class="comment">/* Scan through all the opers in the function looking for</span>
<a name="l01474"></a>01474 <span class="comment">             matches. For the first cb, start after the prologue/alloc op. */</span>
<a name="l01475"></a>01475           scan_cb = fn-&gt;first_cb;
<a name="l01476"></a>01476 
<a name="l01477"></a>01477           <span class="keywordflow">while</span> (scan_cb != NULL)
<a name="l01478"></a>01478             {
<a name="l01479"></a>01479               <span class="keywordflow">if</span> (scan_cb == fn-&gt;first_cb)
<a name="l01480"></a>01480                 scan_op = insert_before_op;
<a name="l01481"></a>01481               <span class="keywordflow">else</span>
<a name="l01482"></a>01482                 scan_op = scan_cb-&gt;first_op;
<a name="l01483"></a>01483 
<a name="l01484"></a>01484               <span class="keywordflow">while</span> (scan_op != NULL)
<a name="l01485"></a>01485                 {
<a name="l01486"></a>01486                   <span class="keywordflow">for</span> (j = 0; j &lt; L_max_dest_operand; j++)
<a name="l01487"></a>01487                     {
<a name="l01488"></a>01488                       <span class="keywordflow">if</span> (L_is_macro (scan_op-&gt;dest[j]) &amp;&amp;
<a name="l01489"></a>01489                           (scan_op-&gt;dest[j]-&gt;value.mac ==
<a name="l01490"></a>01490                            parm_operand-&gt;value.mac))
<a name="l01491"></a>01491                         {
<a name="l01492"></a>01492                           L_delete_operand (scan_op-&gt;dest[j]);
<a name="l01493"></a>01493                           scan_op-&gt;dest[j] = L_copy_operand (parm_vreg);
<a name="l01494"></a>01494                         }
<a name="l01495"></a>01495                     }
<a name="l01496"></a>01496                   <span class="keywordflow">for</span> (j = 0; j &lt; L_max_src_operand; j++)
<a name="l01497"></a>01497                     {
<a name="l01498"></a>01498                       <span class="keywordflow">if</span> (L_is_macro (scan_op-&gt;src[j]) &amp;&amp;
<a name="l01499"></a>01499                           (scan_op-&gt;src[j]-&gt;value.mac ==
<a name="l01500"></a>01500                            parm_operand-&gt;value.mac))
<a name="l01501"></a>01501                         {
<a name="l01502"></a>01502                           L_delete_operand (scan_op-&gt;src[j]);
<a name="l01503"></a>01503                           scan_op-&gt;src[j] = L_copy_operand (parm_vreg);
<a name="l01504"></a>01504                         }
<a name="l01505"></a>01505                     }
<a name="l01506"></a>01506 <span class="preprocessor">#if 0</span>
<a name="l01507"></a>01507 <span class="preprocessor"></span>                  <span class="comment">/* Can't have an int parm in a qualifying pred field. */</span>
<a name="l01508"></a>01508                   <span class="keywordflow">for</span> (j = 0; j &lt; L_max_pred_operand; j++)
<a name="l01509"></a>01509                     {
<a name="l01510"></a>01510                       <span class="keywordflow">if</span> (L_is_macro (scan_op-&gt;pred[j]) &amp;&amp;
<a name="l01511"></a>01511                           (scan_op-&gt;pred[j]-&gt;value.mac ==
<a name="l01512"></a>01512                            parm_operand-&gt;value.mac))
<a name="l01513"></a>01513                         {
<a name="l01514"></a>01514                           L_delete_operand (scan_op-&gt;pred[j]);
<a name="l01515"></a>01515                           scan_op-&gt;pred[j] = L_copy_operand (parm_vreg);
<a name="l01516"></a>01516                         }
<a name="l01517"></a>01517                     }
<a name="l01518"></a>01518 <span class="preprocessor">#endif</span>
<a name="l01519"></a>01519 <span class="preprocessor"></span>                  scan_op = scan_op-&gt;next_op;
<a name="l01520"></a>01520                 }
<a name="l01521"></a>01521 
<a name="l01522"></a>01522               scan_cb = scan_cb-&gt;next_cb;
<a name="l01523"></a>01523             }
<a name="l01524"></a>01524 
<a name="l01525"></a>01525           L_delete_operand (parm_vreg);
<a name="l01526"></a>01526           parm_vreg = NULL;
<a name="l01527"></a>01527           L_delete_operand (parm_class_operand);
<a name="l01528"></a>01528           parm_class_operand = NULL;
<a name="l01529"></a>01529         }
<a name="l01530"></a>01530     }
<a name="l01531"></a>01531 
<a name="l01532"></a>01532   <span class="keywordflow">return</span>;
<a name="l01533"></a>01533 }
<a name="l01534"></a>01534 
<a name="l01535"></a>01535 <span class="keywordtype">int</span>
<a name="l01536"></a><a class="code" href="l__pipe__util_8h.html#b7d0f47ef87d55f7475d9445aecd6fb4">01536</a> <a class="code" href="l__pipe__util_8c.html#bc942e4e2d34aabcfb238a6102ac9618">Lpipe_can_create_fallthru_cb</a> (L_Cb * cb)
<a name="l01537"></a>01537 {
<a name="l01538"></a>01538   L_Cb *fallthru_cb;
<a name="l01539"></a>01539 <span class="preprocessor">#if 0</span>
<a name="l01540"></a>01540 <span class="preprocessor"></span>  L_Flow *fl;
<a name="l01541"></a>01541 
<a name="l01542"></a>01542   fl = L_find_last_flow (cb-&gt;dest_flow);
<a name="l01543"></a>01543 
<a name="l01544"></a>01544   <span class="keywordflow">if</span> (fl-&gt;dst_cb == cb)
<a name="l01545"></a>01545     <span class="keywordflow">return</span> 0;
<a name="l01546"></a>01546 <span class="preprocessor">#endif</span>
<a name="l01547"></a>01547 <span class="preprocessor"></span>
<a name="l01548"></a>01548   <span class="keywordflow">if</span> (L_uncond_branch (cb-&gt;last_op))
<a name="l01549"></a>01549     {
<a name="l01550"></a>01550       fallthru_cb = cb-&gt;last_op-&gt;src[0]-&gt;value.cb;
<a name="l01551"></a>01551       <span class="keywordflow">if</span> (fallthru_cb == cb)
<a name="l01552"></a>01552         <span class="keywordflow">return</span> 0;
<a name="l01553"></a>01553     }
<a name="l01554"></a>01554 
<a name="l01555"></a>01555   <span class="keywordflow">return</span> 1;
<a name="l01556"></a>01556 }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 
<a name="l01559"></a>01559 <span class="keywordtype">void</span>
<a name="l01560"></a><a class="code" href="l__pipe__util_8h.html#a449ba296611b2121b42074e012392ae">01560</a> <a class="code" href="l__pipe__util_8c.html#08dd82ece7672006298b40e75a866e6b">Lpipe_reduce_defines</a> (L_Func * fn)
<a name="l01561"></a>01561 {
<a name="l01562"></a>01562   L_Cb *cb = fn-&gt;first_cb;
<a name="l01563"></a>01563   L_Oper *oper, *next_oper;
<a name="l01564"></a>01564   L_Attr *attr;
<a name="l01565"></a>01565   Set uses;
<a name="l01566"></a>01566   <span class="keywordtype">int</span> num_uses;
<a name="l01567"></a>01567 
<a name="l01568"></a>01568   <span class="keywordflow">while</span> (cb)
<a name="l01569"></a>01569     {
<a name="l01570"></a>01570       attr = L_find_attr (cb-&gt;attr, <span class="stringliteral">"prologue"</span>);
<a name="l01571"></a>01571       <span class="keywordflow">if</span> (attr)
<a name="l01572"></a>01572         {
<a name="l01573"></a>01573           oper = cb-&gt;first_op;
<a name="l01574"></a>01574           <span class="keywordflow">while</span> (oper)
<a name="l01575"></a>01575             {
<a name="l01576"></a>01576               next_oper = oper-&gt;next_op;
<a name="l01577"></a>01577 
<a name="l01578"></a>01578               <span class="keywordflow">if</span> (oper-&gt;opc == Lop_DEFINE &amp;&amp; L_is_reg (oper-&gt;dest[0]))
<a name="l01579"></a>01579                 {
<a name="l01580"></a>01580                   uses = L_get_oper_ROUT_using_opers (oper, oper-&gt;dest[0]);
<a name="l01581"></a>01581                   num_uses = Set_size (uses);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583                   <span class="keywordflow">if</span> (!num_uses)
<a name="l01584"></a>01584                     {
<a name="l01585"></a>01585 <span class="preprocessor">#if 0</span>
<a name="l01586"></a>01586 <span class="preprocessor"></span>                      printf (<span class="stringliteral">"Lpipe_reduce_defines: "</span>
<a name="l01587"></a>01587                               <span class="stringliteral">"Eliminating DEFINE %d of reg %d.\n"</span>,
<a name="l01588"></a>01588                               oper-&gt;id, oper-&gt;dest[0]-&gt;value.r);
<a name="l01589"></a>01589 <span class="preprocessor">#endif</span>
<a name="l01590"></a>01590 <span class="preprocessor"></span>                      L_delete_oper (cb, oper);
<a name="l01591"></a>01591                     }
<a name="l01592"></a>01592                   Set_dispose (uses);
<a name="l01593"></a>01593                 }
<a name="l01594"></a>01594 
<a name="l01595"></a>01595               oper = next_oper;
<a name="l01596"></a>01596             }
<a name="l01597"></a>01597         }
<a name="l01598"></a>01598 
<a name="l01599"></a>01599       cb = cb-&gt;next_cb;
<a name="l01600"></a>01600     }
<a name="l01601"></a>01601 
<a name="l01602"></a>01602   <span class="keywordflow">return</span>;
<a name="l01603"></a>01603 }
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 <span class="keywordtype">void</span>
<a name="l01606"></a><a class="code" href="l__pipe__util_8c.html#9746794fce95842da4036ab2dea2779a">01606</a> <a class="code" href="l__pipe__util_8c.html#9746794fce95842da4036ab2dea2779a">Lpipe_insert_non_rr_defines</a> (L_Func * fn)
<a name="l01607"></a>01607 {
<a name="l01608"></a>01608   L_Cb *cb = fn-&gt;first_cb;
<a name="l01609"></a>01609   L_Oper *oper, *next_oper, *rot_reg_op;
<a name="l01610"></a>01610   L_Attr *attr;
<a name="l01611"></a>01611   Set writes = NULL;
<a name="l01612"></a>01612   <span class="keywordtype">int</span> i;
<a name="l01613"></a>01613   Set rr = <a class="codeRef" doxygen="libregalloc.tag:../../Regalloc/html/" href="../../Regalloc/html/r__regalloc_8c.html#03a8d8fa64ee44840f1b22cf3b942ccb">R_build_rotating_reg_set</a> (fn);
<a name="l01614"></a>01614 
<a name="l01615"></a>01615   <span class="keywordflow">while</span> (cb)
<a name="l01616"></a>01616     {
<a name="l01617"></a>01617       attr = L_find_attr (cb-&gt;attr, <span class="stringliteral">"kernel"</span>);
<a name="l01618"></a>01618       <span class="keywordflow">if</span> (attr)
<a name="l01619"></a>01619         {
<a name="l01620"></a>01620           oper = cb-&gt;first_op;
<a name="l01621"></a>01621           <span class="keywordflow">while</span> (oper)
<a name="l01622"></a>01622             {
<a name="l01623"></a>01623               next_oper = oper-&gt;next_op;
<a name="l01624"></a>01624 
<a name="l01625"></a>01625               <span class="keywordflow">if</span> (oper-&gt;opc != Lop_DEFINE)
<a name="l01626"></a>01626                 {
<a name="l01627"></a>01627                   <span class="keywordflow">for</span> (i = 0; i &lt; L_max_src_operand; i++)
<a name="l01628"></a>01628                     {
<a name="l01629"></a>01629                       <span class="keywordflow">if</span> (L_is_reg (oper-&gt;src[i])
<a name="l01630"></a>01630                           &amp;&amp; !Set_in (rr, oper-&gt;src[i]-&gt;value.r)
<a name="l01631"></a>01631                           &amp;&amp; !Set_in (writes, oper-&gt;src[i]-&gt;value.r))
<a name="l01632"></a>01632                         {
<a name="l01633"></a>01633                           rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01634"></a>01634                           L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01635"></a>01635                           L_insert_oper_after (cb-&gt;prev_cb,
<a name="l01636"></a>01636                                                cb-&gt;prev_cb-&gt;last_op,
<a name="l01637"></a>01637                                                rot_reg_op);
<a name="l01638"></a>01638                           rot_reg_op-&gt;src[0] = L_copy_operand (oper-&gt;src[i]);
<a name="l01639"></a>01639                           rot_reg_op-&gt;dest[0] = L_copy_operand (oper-&gt;src[i]);
<a name="l01640"></a>01640 
<a name="l01641"></a>01641 <span class="preprocessor">#if 0</span>
<a name="l01642"></a>01642 <span class="preprocessor"></span>                          rot_reg_op = L_new_oper (L_fn-&gt;max_oper_id + 1);
<a name="l01643"></a>01643                           L_change_opcode (rot_reg_op, Lop_DEFINE);
<a name="l01644"></a>01644                           L_insert_oper_before (cb-&gt;next_cb,
<a name="l01645"></a>01645                                                 cb-&gt;next_cb-&gt;first_op,
<a name="l01646"></a>01646                                                 rot_reg_op);
<a name="l01647"></a>01647                           rot_reg_op-&gt;src[0] = L_copy_operand (oper-&gt;src[i]);
<a name="l01648"></a>01648                           rot_reg_op-&gt;dest[0] = L_copy_operand (oper-&gt;src[i]);
<a name="l01649"></a>01649 <span class="preprocessor">#endif</span>
<a name="l01650"></a>01650 <span class="preprocessor"></span>
<a name="l01651"></a>01651                           writes = Set_add (writes, oper-&gt;src[i]-&gt;value.r);
<a name="l01652"></a>01652                         }
<a name="l01653"></a>01653                     }
<a name="l01654"></a>01654                   <span class="keywordflow">for</span> (i = 0; i &lt; L_max_dest_operand; i++)
<a name="l01655"></a>01655                     {
<a name="l01656"></a>01656                       <span class="keywordflow">if</span> (L_is_reg (oper-&gt;src[i])
<a name="l01657"></a>01657                           &amp;&amp; !Set_in (rr, oper-&gt;src[i]-&gt;value.r))
<a name="l01658"></a>01658                         {
<a name="l01659"></a>01659                           writes = Set_add (writes, oper-&gt;src[i]-&gt;value.r);
<a name="l01660"></a>01660                         }
<a name="l01661"></a>01661                     }
<a name="l01662"></a>01662                 }
<a name="l01663"></a>01663 
<a name="l01664"></a>01664               oper = next_oper;
<a name="l01665"></a>01665             }
<a name="l01666"></a>01666         }
<a name="l01667"></a>01667 
<a name="l01668"></a>01668       writes = Set_dispose (writes);
<a name="l01669"></a>01669 
<a name="l01670"></a>01670       cb = cb-&gt;next_cb;
<a name="l01671"></a>01671     }
<a name="l01672"></a>01672   <span class="keywordflow">return</span>;
<a name="l01673"></a>01673 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Aug 30 17:59:22 2014 for libsoftpipe by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
